<!DOCTYPE html>
<html lang="ko" dir="ltr" typeof="bibo:Document w3p:REC" about="" property="dcterms:language" content="ko">
<head>
  <title>포인터 이벤트</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta charset="UTF-8">
  <style>
      .issue {background: #fcc !important;}
      pre.idl::before, pre.example::before { font-family: sans-serif !important; }
      ol:not([data-class='note-list'])>li { margin-bottom: 1em; }
  </style>
  <style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 {
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #C83500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

@media print {
    .removeOnSave {
        display: none;
    }
}
</style><style>/* --- EXAMPLES --- */
div.example-title {
    min-width: 7.5em;
    color: #b9ab2d;
}
div.example-title span {
    text-transform: uppercase;
}
aside.example, div.example, div.illegal-example {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
div.illegal-example { color: red }
div.illegal-example p { color: black }
aside.example, div.example {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
    border-color: #e0cb52;
    background: #fcfaee;
}

aside.example div.example {
    border-left-width: .1em;
    border-color: #999;
    background: #fff;
}
aside.example div.example div.example-title {
    color: #999;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title { color: #2b2; }
div.issue-title span, div.note-title span {
    text-transform: uppercase;
}
div.note, div.issue {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .issue > p:first-child { margin-top: 0 }
.issue, .note {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.issue { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note {
    border-color: #52e052;
    background: #e9fbe9;
}


</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #005a9c;
}
a.idlEnumItem {
    color:  #000;
    border-bottom:  1px dotted #ccc;
    text-decoration: none;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #005a9c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlCtor*/
.idlCtorName {
    color:  #ff4500;
}
.idlCtorName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName, .idlDefaultValue {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlSectionComment*/
.idlSectionComment {
    color: gray;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.constructors, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .constructors dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .constructors dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.constructors dt code {
    background:  #cfc;
}

.attributes dd, .methods dd, .constants dd, .constructors dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}

dt#feedback {
  margin-top: 1em;
}

</style>
<link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/W3C-REC">
<link rel="stylesheet" href="trans.css">
<!--[if lt IE 9]><script src='https://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]-->
</head>
  <body class="h-entry" role="document" id="respecDocument"><div class="head" role="contentinfo" id="respecHeader">
  <p>
		<a href="http://www.w3.org/"><img width="72" height="48" src="https://www.w3.org/Icons/w3c_home" alt="W3C"></a>
  </p>
  <h1 class="title p-name" id="title" property="dcterms:title">포인터 이벤트</h1>
  <h2 property="dcterms:issued" datatype="xsd:dateTime" content="2015-02-24T05:00:00.000Z" id="w3c-recommendation-24-february-2015"><time class="dt-published" datetime="2015-02-24">2015년 2월 24일</time> <abbr title="World Wide Web Consortium">W3C</abbr> 권고안</h2>
  <dl>

      <dt>이 버전:</dt>
      <dd><a class="u-url" href="http://www.w3.org/TR/2015/REC-pointerevents-20150224/">http://www.w3.org/TR/2015/REC-pointerevents-20150224/</a></dd>
      <dt>마지막 발행 버전:</dt>
      <dd><a href="http://www.w3.org/TR/pointerevents/">http://www.w3.org/TR/pointerevents/</a></dd>
      <dt>마지막 Editor's draft:</dt>
      <dd><a href="https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html">https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html</a></dd>
      <dt>Test suite:</dt>
      <dd><a href="https://github.com/w3c/web-platform-tests/tree/master/pointerevents">https://github.com/w3c/web-platform-tests/tree/master/pointerevents</a></dd>
      <dt>구현 보고서:</dt>
      <dd><a href="http://w3c.github.io/test-results/pointerevents/all.html">http://w3c.github.io/test-results/pointerevents/all.html</a></dd>
      <dt>이전 버전:</dt>
      <dd><a rel="dcterms:replaces" href="http://www.w3.org/TR/2014/PR-pointerevents-20141216/">http://www.w3.org/TR/2014/PR-pointerevents-20141216/</a></dd>
    <dt>Editors:</dt>
    <dd class="p-author h-card vcard" rel="bibo:editor" inlist=""><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Jacob Rossi</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="http://www.microsoft.com/">Microsoft Corporation</a></span></dd>

    <dd class="p-author h-card vcard" rel="bibo:editor" inlist=""><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Matt Brubeck</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="http://www.mozilla.org/">Mozilla</a></span></dd>

    <dt id="feedback">피드백:</dt>
    <dd>포인터 이벤트 워킹 그룹 메일링 리스트: <a href="mailto:public-pointer-events@w3.org">public-pointer-events@w3.org</a>
     (<a href="http://lists.w3.org/Archives/Public/public-pointer-events/">archives</a>)</dd>
  </dl>
  <p>이 문서의 발행 이후 보고된 에러와 이슈는 <a href="https://www.w3.org/wiki/PointerEvents/errata"><strong>errata</strong></a>에서 확인 가능합니다.</p>

  <p><a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=pointerevents"> <strong>번역본</strong></a>도 제공합니다.</p>
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©
        2015

        <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
        (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
        <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>),

        All Rights Reserved.

        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and

          <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>

        rules apply.
      </p>


  <hr>
</div>
    <section id="abstract" class="introductory" property="dcterms:abstract" datatype="" typeof="bibo:Chapter" resource="#abstract" rel="bibo:Chapter"><h2 role="heading" id="h2_abstract">개요</h2>
   <p>
     이 문서는 마우스, 펜, 터치스크린 등을 포함한 하드웨어에 상관없이 포인터 입력을 핸들링하기 위한 이벤트와 관련 인터페이스를 정의합니다.
     이미 존재하는 마우스 기반 콘텐츠와 호환성을 유지하기 위해, 이 스펙문서는 다른 포인터 디바이스를 위한 마우스 이벤트 실행[<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]도 소개하고 있습니다. 
   </p>
   </section>
      <section rel="bibo:chapter" resource="#sotd" typeof="bibo:Chapter" id="sotd" class="introductory">
        <h2 id="h2_sotd" role="heading" aria-level="1">이 문서의 상태</h2>
        <p lang=ko><em>
        이 섹션은 문서를 발행하였을 때 상태를 설명합니다.
        다른 문서가 이 문서를 대체할 수도 있습니다.
        이 문서 및 <abbr title="World Wide Web Consortium">W3C</abbr>에서 공개한 다른 문서의 최신 버전은
				<a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at http://www.w3.org/TR/에서 확인 가능합니다.
        </em></p> 
        <p lang=ko id="stability-disclaimer">이 문서를 권고안으로 발행함으로써 <abbr title="World Wide Web Consortium">W3C</abbr>는 포인터 이벤트 권고안이
          권고안 프로세스로 인해 DOM 레벨 3 이벤트 스펙 문서나 DOM4 스펙 문서가 변경하더라도 영향을 받지 않을 거라 기대합니다.
        <p lang=ko><a href="http://www.w3.org/2012/pointerevents/">포인터 이벤트 워킹 그룹</a>은 <a href="http://w3c.github.io/test-results/pointerevents/all.html">포인터 이벤트 test suite 및 구현 보고서</a>로 구현성과 상호 운용성을 입증합니다.
        <p lang=ko>이 문서는 W3C 멤버, 소프트웨어 개발자, 다른 W3C 그룹과 관심 단체가 리뷰하였으며 디렉터의 승인을 받아 W3C 권고안으로 등록하였습니다.
          이 문서는 안정적인 문서로 다른 문서에서 참고 자료로 사용하거나 인용할 수 있습니다.
          스펙 문서를 권고안으로 제정하여 W3C가 하는 역할은 스펙 문서에 관심을 모으고 다방면으로 퍼뜨리는 일입니다.
          이를 통해 웹의 기능과 상호 운용성 향상을 기대할 수 있습니다.
       <p lang="ko">이 문서는 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">2004년 2월 6일 W3C 특허 정책</a>을 따르는 그룹에서 작성하였습니다.
       W3C는 그룹의 성과물에 관련하여 <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">모든 공개 특허 공개 리스트</a>를 관리합니다.
       여기에는 특허 공개에 대한 지시사항도 포함합니다.
       특허에 대해서 충분한 지식이 있는 사람이, 
       스펙 문서의 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a>에 인정된다고 파악되는 경우, 
       <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C 특허 정책 제 6장</a>에 의거하여 정보를 공개해야 할 필요가 있습니다.</p>
        <p lang=ko>이 문서는 <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">2005년 10월 14일 <abbr title="World Wide Web Consortium">W3C</abbr> 프로세스 문서</a>를 통해 관리하고 있습니다.</p>
      </section>
    
    <section id="toc"><h2 class="introductory" role="heading" id="h2_toc">Table of Contents</h2><ul class="toc" role="directory" id="respecContents"><li class="tocline"><a href="#intro" class="tocxref"><span class="secno">1. </span>Introduction</a></li><li class="tocline"><a href="#conformance" class="tocxref"><span class="secno">2. </span>Conformance</a></li><li class="tocline"><a href="#examples" class="tocxref"><span class="secno">3. </span>Examples</a></li><li class="tocline"><a href="#glossary" class="tocxref"><span class="secno">4. </span>Glossary</a></li><li class="tocline"><a href="#pointer-events-and-interfaces" class="tocxref"><span class="secno">5. </span>Pointer Events and Interfaces</a><ul class="toc"><li class="tocline"><a href="#pointerevent-interface" class="tocxref"><span class="secno">5.1 </span><code>PointerEvent</code> Interface</a><ul class="toc"><li class="tocline"><a href="#button-states" class="tocxref"><span class="secno">5.1.1 </span>Button States</a><ul class="toc"><li class="tocline"><a href="#chorded-button-interactions" class="tocxref"><span class="secno">5.1.1.1 </span><span title="chorded buttons">Chorded Button Interactions</span></a></li></ul></li><li class="tocline"><a href="#the-primary-pointer" class="tocxref"><span class="secno">5.1.2 </span><span title="primary pointer">The Primary Pointer</span></a></li></ul></li><li class="tocline"><a href="#pointer-event-types" class="tocxref"><span class="secno">5.2 </span>Pointer Event Types</a><ul class="toc"><li class="tocline"><a href="#firing-events-using-the-pointerevent-interface" class="tocxref"><span class="secno">5.2.1 </span>Firing events using the <code>PointerEvent</code> interface</a></li><li class="tocline"><a href="#list-of-pointer-events" class="tocxref"><span class="secno">5.2.2 </span>List of Pointer Events</a></li><li class="tocline"><a href="#the-pointerover-event" class="tocxref"><span class="secno">5.2.3 </span><span title="pointerover">The <code>pointerover</code> event</span></a></li><li class="tocline"><a href="#the-pointerenter-event" class="tocxref"><span class="secno">5.2.4 </span><span title="pointerenter">The <code>pointerenter</code> event</span></a></li><li class="tocline"><a href="#the-pointerdown-event" class="tocxref"><span class="secno">5.2.5 </span><span title="pointerdown">The <code>pointerdown</code> event</span></a></li><li class="tocline"><a href="#the-pointermove-event" class="tocxref"><span class="secno">5.2.6 </span><span title="pointermove">The <code>pointermove</code> event</span></a></li><li class="tocline"><a href="#the-pointerup-event" class="tocxref"><span class="secno">5.2.7 </span><span title="pointerup">The <code>pointerup</code> event</span></a></li><li class="tocline"><a href="#the-pointercancel-event" class="tocxref"><span class="secno">5.2.8 </span><span title="pointercancel">The <code>pointercancel</code> event</span></a></li><li class="tocline"><a href="#the-pointerout-event" class="tocxref"><span class="secno">5.2.9 </span><span title="pointerout">The <code>pointerout</code> event</span></a></li><li class="tocline"><a href="#the-pointerleave-event" class="tocxref"><span class="secno">5.2.10 </span><span title="pointerleave">The <code>pointerleave</code> event</span></a></li><li class="tocline"><a href="#the-gotpointercapture-event" class="tocxref"><span class="secno">5.2.11 </span><span title="gotpointercapture">The <code>gotpointercapture</code> event</span></a></li><li class="tocline"><a href="#the-lostpointercapture-event" class="tocxref"><span class="secno">5.2.12 </span><span title="lostpointercapture">The <code>lostpointercapture</code> event</span></a></li></ul></li></ul></li><li class="tocline"><a href="#extensions-to-the-element-interface" class="tocxref"><span class="secno">6. </span>Extensions to the <code>Element</code> interface</a></li><li class="tocline"><a href="#extensions-to-the-globaleventhandlers-interface" class="tocxref"><span class="secno">7. </span>Extensions to the <code>GlobalEventHandlers</code> interface</a><ul class="toc"><li class="tocline"><a href="#attributes" class="tocxref"><span class="secno">7.1 </span>Attributes</a></li></ul></li><li class="tocline"><a href="#extensions-to-the-navigator-interface" class="tocxref"><span class="secno">8. </span>Extensions to the <code>Navigator</code> interface</a></li><li class="tocline"><a href="#declaring-candidate-regions-for-default-touch-behaviors" class="tocxref"><span class="secno">9. </span>Declaring candidate regions for default touch behaviors</a><ul class="toc"><li class="tocline"><a href="#the-touch-action-css-property" class="tocxref"><span class="secno">9.1 </span>The <code>touch-action</code> CSS property</a></li></ul></li><li class="tocline"><a href="#pointer-capture" class="tocxref"><span class="secno">10. </span><span title="Pointer Capture">Pointer Capture</span></a><ul class="toc"><li class="tocline"><a href="#setting-pointer-capture" class="tocxref"><span class="secno">10.1 </span>Setting Pointer Capture</a></li><li class="tocline"><a href="#releasing-pointer-capture" class="tocxref"><span class="secno">10.2 </span>Releasing Pointer Capture</a></li><li class="tocline"><a href="#implicit-pointer-capture" class="tocxref"><span class="secno">10.3 </span>Implicit Pointer Capture</a><ul class="toc"><li class="tocline"><a href="#implicit-release-of-pointer-capture" class="tocxref"><span class="secno">10.3.1 </span>Implicit Release of Pointer Capture</a></li></ul></li></ul></li><li class="tocline"><a href="#compatibility-mapping-with-mouse-events" class="tocxref"><span class="secno">11. </span><span title="compatibility mouse events">Compatibility Mapping with Mouse Events</span></a><ul class="toc"><li class="tocline"><a href="#mapping-for-devices-that-support-hover" class="tocxref"><span class="secno">11.1 </span>Mapping for devices that support hover</a></li><li class="tocline"><a href="#mapping-for-devices-that-do-not-support-hover" class="tocxref"><span class="secno">11.2 </span>Mapping for devices that do not support hover</a></li></ul></li><li class="tocline"><a href="#acknowledgments" class="tocxref"><span class="secno">A. </span>Acknowledgments</a></li><li class="tocline"><a href="#revision-history" class="tocxref"><span class="secno">B. </span>Revision History</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">C. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">C.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">C.2 </span>Informative references</a></li></ul></li></ul></section>
    
    <section id="intro" class="informative" typeof="bibo:Chapter" resource="#intro" rel="bibo:Chapter">
      <!--OddPage--><h2 role="heading" id="h2_intro"><span class="secno">1. </span>소개</h2>
      <p lang=ko><em>이 섹션은 표준에 준하는 내용이 아닙니다.</em></p>
      <div>
      <p lang=ko>
        오늘날 많은 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>] 콘텐츠는 마우스 입력으로 사용하며, 마우스 입력을 위해 디자인하기도 합니다.
        여기에 사용자 정의 방법으로 입력을 제어하기 위해서 보통 
        [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>] 마우스 이벤트를 사용합니다.
        새로운 컴퓨팅 디바이스가 많아졌으나, 터치스크린, 펜 입력 등을 포함한 다른 형태의 입력이 통합되지 않았습니다.
        이벤트 타입은 각각의 입력 형태에 독립적인 처리 방법을 가지도록 제안되었습니다.
        그러나, 이 방법은 새로운 입력 타입을 지원해야 할 때 이벤트 처리에 대한 간접 비용 및 불필요한 중복을 일으킵니다.
        한 디바이스 타입만 생각하고 콘텐츠를 작성한 경우 호환성 문제를 일으킬 가능성도 있습니다.
        거기에 더해, 이미 존재하는 마우스 베이스 콘텐츠와 호환하기 위해, 
        대부분의 <a title="user agent" class="internalDFN" href="#dfn-user-agent">유저 에이전트</a>가 모든 입력 타입에 마우스 이벤트를 발생시켰습니다.
        이는 실제로 마우스 디바이스에서 발생한 이벤트인지, 다른 디바이스에서 입력한 내용을 호환성을 위해 마우스 이벤트로 변경하여 생성한 것인지
        판단을 모호하게 만듭니다.
      </p>
      <p lang=ko>여러개의 입력 타입으로 인한 코딩 코스트를 없애면서 위에서 설명한 마우스 이벤트의 모호성에 도움을 주기 위해, 
        이 스펙 문서는 <a title="pointer" class="internalDFN" href="#dfn-pointer">포인터</a>라 부르는 더 추상적인 입력 형태를 정의합니다.
        포인터는 마우스 커서, 펜, (멀티 터치를 포함한) 터치 및 다른 포인팅 입력 디바이스가 생성한 스크린과 맞닿는 모든 포인트에 사용이 가능합니다.
        이 모델은 유저가 어떤 하드웨어를 사용하는 지와 상관 없이 사이트와 어플리케이션을 잘 동작하도록 쉽게 작성할 수 있게 합니다.
        장치 고유의 처리를 요구하는 시나리오를 위해, 이 스펙문서에서는 이벤트가 발생하는 디바이스 타입을 검사하기 위한 속성을 정의합니다.
        주 목적은 단지 경험 증가를 위해 필요한 디바이스별 고유 처리를 여전히 허용하면서 디바이스에 구애받지 않는 입력을 쉽게 작성할 수 있게 하는
        이벤트와 인터페이스의 단일 세트를 제공하는 것입니다.
      </p>
			<p lang=ko> 추가적인 주된 목표는 스크립트 실행을 막지않고, 스크롤 같은 기본 터치 액션을 처리하기 위한 멀티 스레드 유저 에이전트를 가능하게 하는 것입니다.
	  <div class="note" lang=ko><div class="note-title" aria-level="1" role="heading" id="h_note_1"><span>노트</span></div><div class="">
		<p>이 스펙 문서가 다양한 포인터 입력을 위한 통합 이벤트 모델을 정의하나, 키보드나 키보드 형태의 인터페이스 같은 다른 입력 형태를 이 모델에서 다루지 않습니다 (예를 들면, 유저가 포커스를 가져갈 수 있는 컨트롤이나 요소들을 통한 유저 순차적 네비게이션을 허용하는 스크린 리더나 터치스크린 디바이스에서만 동작하는 보조 도구같은 것들입니다). 유저 에이전트는 이러한 인터페이스를 지원하기 위해 포인터 이벤트를 생성할 수 있지만, 이 시나리오를 이 스펙 문서에서 다루지 않습니다.</p>
		<p>
    첫번째 인스턴스에서, 작성자가 <code>focus</code>, <code>blue</code>, <code>click</code> 같은 
    하이 레벨 이벤트에 대응하는 모든 입력 형태를 위해 동일한 기능을 제공하기를 권장합니다.
    그러나, (포인터 이벤트 같은) 로우 레벨 이벤트를 사용할 때, 작성자는 모든 입력 형태를 반드시 지원하는 것을 권장합니다.
    키보드와 키보드 형태의 인터페이스같은 경우, 명백히 키보드 이벤트 처리를 추가해야 합니다.
    추가적인 내용은 <a href="http://www.w3.org/TR/WCAG20/#keyboard-operation">WCAG 2.0 Guideline 2.1</a>를 참고하시길 바랍니다.</p>
	  </div></div>
	<figure id="fig-a-pointer-is-a-hardware-agnostic-representation-of-input-devices-that-can-target-a-specific-coordinate-or-set-of-coordinates-on-a-screen.x">
		<img src="pointer.png" alt="마우스, 펜, 터치 등 입력을 모은 포인터 입력">
		<figcaption>Fig. <span class="figno">1</span> <span class="fig-title">포인터는 스크린 위에서 고유의 좌표(좌표의 세트)를 목표로 하는 입력 기기를 하드웨어에 상관없이 나타냅니다.</span></figcaption>
	  </figure>
        <p lang=ko>포괄적인 포인터 입력을 위한 이벤트는 pointerdown, pointermove, pointerup, pointerover, pointerout 등 마우스에서 사용하던 것과 유사한 게 많습니다. 이는 마우스 이벤트에서 포인터 이벤트로 콘텐츠를 이동을 쉽고 용이하게 합니다. 포인터 이벤트는 클라이언트 좌표, 타겟 요소, 버튼 상태 등 현재 마우스 이벤트에서 사용하는 속성을 제공합니다. 여기에 더해 압력, 접촉 기하, 기울기 등 다른 입력 형태를 위한 새로운 속성도 제공합니다. 따라서 다른 형태의 인풋 타입 사이에 로직을 공유할 때 의미가 통하게, 최적의 경험을 얻을 수 있게 필요한 특정 입력 형태만을 위한 커스터마이징 등을 포인터 이벤트에서 쉽게 작성할 수 있게 합니다.</p>
    <p lang=ko>
      포인터 디바이스가 여러 입력 디바이스를 소스로 할 때, 다른 디바이스 고유 이벤트 세트에서 생성하는 건 정의하지 않습니다.
      가능성과 호환을 부추기기 위해, 이 스펙에서 마우스 이벤트, 터치 이벤트 같은 다른 디바이스 고유 이벤트를 지원하기를 필수로 하지 않습니다. 
      유저 에이전트는 다른 디바이스 이벤트를 지원하지 않고 포인터 이벤트만 지원할 수 있습니다.
      마우스 고유 이벤트로 작성한 콘텐츠의 호환성을 위해, 이 스펙 문서는 마우스 대신 다른 디바이스의 포인터 입력을 기반으로 한 호환 마우스 이벤트 생성 방법을 설명하는 섹션을 제공합니다.
	  <div class="note" lang=ko><div class="note-title" aria-level="1" role="heading" id="h_note_2"><span>노트</span></div><div class="informative">
    이 스펙 문서는 포인터 이벤트와 <a href="http://www.w3.org/TR/touch-events/">터치 이벤트</a> 양쪽 다 지원하는 유저 에이전트의 예상 행동에 대한 어드바이스를 제공하지 않습니다. 두 스펙간 관계에 대한 더 자세한 정보는, <a href="http://www.w3.org/community/touchevents/">터치 이벤트 커뮤니티 그룹</a>을 보시길 바랍니다.
	  </div></div>
	  </div>
    </section>
<section id="conformance" typeof="bibo:Chapter" resource="#conformance" rel="bibo:Chapter"><!--OddPage--><h2 role="heading" id="h2_conformance"><span class="secno">2. </span>적합성</h2>
<p lang=ko>
  이 스펙문서 내에서 예제, 노트, 작성 가이드라인, 다이어그램 및 명시적으로 '이 섹션은 표준에 준하는 내용이 아닙니다'라 표기된 내용은 표준에 준하는 내용이 아닙니다.
	그 외는 모두 표준에 준하는 내용입니다.
</p>
<p id="respecRFC2119"><em class="rfc2119" title="MAY">MAY</em>, <em class="rfc2119" title="MUST">MUST</em>, <em class="rfc2119" title="MUST NOT">MUST NOT</em>, <em class="rfc2119" title="OPTIONAL">OPTIONAL</em>, <em class="rfc2119" title="SHOULD">SHOULD</em> 키워드는 [<cite><a class="bibref" href="#bib-RFC2119">RFC2119</a></cite>]에서 기술하는대로 해석합니다.
</p>
</section>
<section class="informative" id="examples">
	<!--OddPage--><h2 role="heading" id="h2_examples"><span class="secno">3. </span>예제</h2>
  <p lang=ko><em>이 섹션은 표준에 준하는 내용이 아닙니다.</em></p>
  <p lang=ko>아래 예제들은 이 스펙 문서에서 사용해야 하는 API를 어떻게 사용해야 하는지 입증하는 코드입니다.</p>
<div class="example"><div class="example-title"><span>예제 1</span>: 기본 HTML5 Canvas 페인팅 예제</div><pre id="example_1" class="example">&lt;style&gt;
  /* Disable intrinsic user agent touch behaviors (such as panning or zooming) so
  that all events on the canvas element are given to the application instead. */

  canvas {
    touch-action: none;
  }
&lt;/style&gt;

&lt;canvas id="drawSurface" width="500px" height="500px" style="border:1px solid black;"&gt;&lt;/canvas&gt;

&lt;script type='text/javascript'&gt;
    var canvas = document.getElementById("drawSurface"),
    context = canvas.getContext("2d");

    if (window.PointerEvent) {
        canvas.addEventListener("pointermove", paint, false);
        if(window.navigator.maxTouchPoints&gt;1)
    	   /* User agent and hardware support multi-touch */
    }
    else {
        //Provide fallback for user agents that do not support Pointer Events
        canvas.addEventListener("mousemove", paint, false);
    }

    function paint(event) {
        if(event.buttons&gt;0)
    	   context.fillRect(event.clientX, event.clientY, 5, 5);
    }
&lt;/script&gt;</pre></div>
<div class="example"><div class="example-title"><span>예제 2</span>: 유저 입력 형태 감지하기</div><pre id="example_2" class="example">window.addEventListener("pointerdown", detectInputType, false);

function detectInputType(event) {
    switch(event.pointerType) {
        case "mouse":
            /* mouse input detected */
            break;
        case "pen":
            /* pen/stylus input detected */
            break;
        case "touch":
            /* touch input detected */
            break;
        default:
            /* pointerType is empty (could not be detected)
            or UA-specific custom type */
    }
}</pre></div>
<div class="example"><div class="example-title"><span>예제 3</span>: 접촉 기하에 매치해 요소 리사이징</div><pre id="example_3" class="example">&lt;div style="position:absolute; top:0px; left:0px; width:100px;height:100px;"&gt;&lt;/div&gt;
&lt;script&gt;
window.addEventListener("pointerdown", checkPointerSize, false);

function checkPointerSize(event) {
    event.target.style.width = event.width + "px";
    event.target.style.height = event.height + "px";
}
&lt;/script&gt;</pre></div>
<div class="example"><div class="example-title"><span>예제 4</span>: 스크립트에서	신뢰할 수 없는 포인터 이벤트 발생하기</div><pre id="example_4" class="example">var event = new PointerEvent("pointerover",
   {bubbles: true,
    cancelable: true,
    pointerId: 42,
    pointerType: "pen",
    clientX: 300,
    clientY: 500
    });
eventTarget.dispatchEvent(event); </pre></div>
</section>
	<section class="informative" id="glossary">
		<!--OddPage--><h2 role="heading" id="h2_glossary"><span class="secno">4. </span>용어 사전</h2>
    <p lang=ko><em>이 섹션은 표준에 준하는 내용이 아닙니다.</em></p>
		<dl>
			<dt><dfn id="dfn-active-buttons-state">버튼 활성 상태</dfn></dt>
				<dd>
        포인터 <code>buttons</code> 속성 값이 0이 아닌 상태를 나타냅니다.
        마우스에서 적어도 한개 이상의 버튼을 눌렀을 때를 나타냅니다.
        터치에서 디지타이저에 물리적으로 접촉했을 때를 나타냅니다.
        펜에서 디지타이저에 펜이 물리적으로 접촉했을 때를 나타냅니다.
			<dt><dfn id="dfn-active-pointer">활성 포인터</dfn></dt>
				<dd>
        모든 터치 접촉, 스타일러스 펜, 마우스 커서 및 다른 포인터에 이벤트를 줄 수 있습니다.
        만약 포인터를 주는게 가능하다면(유니크한 <code>pointerId</code>로 식별하는) 문서를 포함한 추가 이벤트를 부여할 수 있으며, 
        포인터는 활성 상태를 유지할 것입니다. 예를 들면:
					<ul>
						<li>디바이스에 연결된 마우스는 항상 활성상태입니다.</li>
						<li>스크린에 닿은 터치는 활성상태로 고려해야 합니다.</li>
						<li>만약 터치 접촉이나 스타일러스 펜이 디지타이저 범위 위를 벗어난 경우, 더 이상 활성 상태로 고려하지 않아야 합니다.</li>
					</ul>
					<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_3"><span>노트</span></div><div class="">
          몇몇 플랫폼에서 활성 포인터의 세트는 유저에이전트 타겟이 아닌 것을 포함한 모든 디바이스 입력을 포함합니다. (즉 다른 어플리케이션 타겟입니다)</div></div>
				</dd>
			<dt><dfn id="dfn-canceled-event">취소 이벤트</dfn></dt>
				<dd>
          기본 액션을 <code>preventDefault()</code>으로 막았거나, 이벤트 핸들러에 <code>false</code>를 반환하거나,
          [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]와 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]에서 정의하는 다른 이벤트를 나타냅니다.</dd>
			<dt><dfn id="dfn-contact-geometry">접촉 기하</dfn></dt>
				<dd>
          디지타이저에서 (보통 터치) 인풋 바운딩 박스를 의미합니다. 이는 보통 하나의 픽셀보다 조잡한 포인터 입력 해상도와 디바이스를 의미합니다. 몇몇 디바이스는 이 데이터를 모두 보고하지 않을 수 있습니다.</dd>
			<dt><dfn id="dfn-digitizer">디지타이저</dfn></dt>
				<dd>
         근접하거나 접촉한 입력을 감지할 수 있는 표면을 가지는 감지 장치 입력 형태. 일반적으로, 스타일러스 펜이나 터치 접촉을 통해 감지하는 표면을 나타냅니다.
        </dd>
			<dt><dfn id="dfn-hit-test">히트 테스트</dfn></dt>
				<dd>사용자 에이전트의 포인터 이벤트 대상 요소를 정의하는 프로세스.
          일반적으로 포인터 위치 같은 스크린 미디어에서 보여지는 문서 내 요소의 비주얼 레이아웃에에 따라 결정합니다.</dd>
			<dt><dfn id="dfn-pointer">포인터</dfn></dt>
				<dd>
        하드웨어와 상관없이 스크린 상에서 마우스, 펜, 터치 접촉 같은 조유 좌표 (좌표의 세트)에 타겟 가능한 입력 기기를 나타냅니다.
        </dd>
			<dt><dfn id="dfn-user-agent">유저 에이전트</dfn></dt>
				<dd>
        보통 클라이언트 머신에서 돌아가는 유저를 대신해 검색, 해석, 실행, 표현, 콘텐츠 생성을 행하는 브라우저나 콘텐츠 저작도구 같은 프로그램.
        </dd>
			<dt><dfn id="dfn-queue-a-task">태스크 대기 행렬</dfn></dt>
				<dd>
					 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]에서 정의한,적절한 이벤트 루프의 태스크 대기 행렬에 이벤트 태스트를 더한 것</dd>
		</dl>
	</section>
   <section id="pointer-events-and-interfaces">
     <!--OddPage--><h2 role="heading" id="h2_pointer-events-and-interfaces"><span class="secno">5. </span>포인터 이벤트와 인터페이스</h2>
     <section id="pointerevent-interface">
       <h3 role="heading" id="h3_pointerevent-interface"><span class="secno">5.1 </span><code>PointerEvent</code> 인터페이스</h3>
       <div>
			<pre class="idl"><span class="idlInterface" id="idl-def-PointerEvent"><span class="idlDictionary" id="idl-def-PointerEventInit">dictionary <span class="idlDictionaryID">PointerEventInit</span> : <span class="idlSuperclass">MouseEventInit</span> {
<span class="idlMember">    <span class="idlMemberType">long</span>      <span class="idlMemberName"><a href="#widl-PointerEventInit-pointerId">pointerId</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">double</span>    <span class="idlMemberName"><a href="#widl-PointerEventInit-width">width</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">double</span>    <span class="idlMemberName"><a href="#widl-PointerEventInit-height">height</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">float</span>     <span class="idlMemberName"><a href="#widl-PointerEventInit-pressure">pressure</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">long</span>      <span class="idlMemberName"><a href="#widl-PointerEventInit-tiltX">tiltX</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">long</span>      <span class="idlMemberName"><a href="#widl-PointerEventInit-tiltY">tiltY</a></span> = <span class="idlMemberValue">0</span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-PointerEventInit-pointerType">pointerType</a></span> = <span class="idlMemberValue">""</span>;</span>
<span class="idlMember">    <span class="idlMemberType">boolean</span>   <span class="idlMemberName"><a href="#widl-PointerEventInit-isPrimary">isPrimary</a></span> = <span class="idlMemberValue">false</span>;</span>
};</span><br><br>[<span class="extAttr">Constructor(DOMString type, optional PointerEventInit eventInitDict)</span>]
interface <span class="idlInterfaceID">PointerEvent</span> : <span class="idlSuperclass">MouseEvent</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span>      <span class="idlAttrName"><a href="#widl-PointerEvent-pointerId">pointerId</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">double</span>    <span class="idlAttrName"><a href="#widl-PointerEvent-width">width</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">double</span>    <span class="idlAttrName"><a href="#widl-PointerEvent-height">height</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">float</span>     <span class="idlAttrName"><a href="#widl-PointerEvent-pressure">pressure</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span>      <span class="idlAttrName"><a href="#widl-PointerEvent-tiltX">tiltX</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span>      <span class="idlAttrName"><a href="#widl-PointerEvent-tiltY">tiltY</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">DOMString</span> <span class="idlAttrName"><a href="#widl-PointerEvent-pointerType">pointerType</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">boolean</span>   <span class="idlAttrName"><a href="#widl-PointerEvent-isPrimary">isPrimary</a></span>;</span>
};</span></pre><section><h4 id="attributes-1" role="heading">속성</h4><dl class="attributes">
          <dt id="widl-PointerEvent-pointerId"><code>pointerId</code> <span class="idlAttrType">long</span> 타입, 읽기 전용</dt><dd>
					<p lang=ko>이벤트를 일으키는 포인터를 위한 고유 식별자. 이 식별자는 <em class="rfc2119" title="MUST">반드시</em> 
             서로 다른 <a title="active pointer" class="internalDFN" href="#dfn-active-pointer">활성 포인터</a>에서 고유값을 가져야합니다. [<em class="rfc2119" title="MUST">MUST</em>]
             필요한 경우 유저에이전트는 이전 활성 포인터에서 사용했지만 지금은 사용하지 않는 <code>pointerId</code> 값을 재활용 할 수도 있습니다. [<em class="rfc2119" title="MAY">MAY</em>]</p>
					<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_4">노트</div><section class="">
         <code>pointerId</code> 선택 알고리즘은 구현체 고유의 알고리즘입니다.
         따라서 작성자는 값이 다른 모든 활성 포인터에 대한 식별자 외 특정 의미를 전달할 수 없습니다.
         예를 들어, 값이 단조롭게 증가하는 걸 보장하지 않습니다.</section></div>
				</dd><dt id="widl-PointerEvent-width"><code>width</code> <span class="idlAttrType">double</span> 타입, 읽기 전용</dt><dd>
					
         포인터의 <a title="contact geometry" class="internalDFN" href="#dfn-contact-geometry">접촉 기하</a>인 CSS 픽셀 ([<cite><a class="bibref" href="#bib-CSS21">CSS21</a></cite>]) width (X축 상 크기)
         이 값은 포인터가 주어진 각 이벤트별로 업데이트 할 수 있습니다. [<em class="rfc2119" title="MAY">MAY</em>]
         접촉 기하를 가지고 있지만 실제 기하를 하드웨어가 보고하지 않은 경우 디바이스의 기본 값을 <a title="user agent" class="internalDFN" href="#dfn-user-agent">유저 에이전트</a>가 그 포인터 타입의 대략적인 평균 형태로 제공해야만합니다. [<em class="rfc2119" title="SHOULD">SHOULD</em>] 다른 경우라면 이 값은 반드시 0입니다. [<em class="rfc2119" title="MUST">MUST</em>]
				</dd><dt id="widl-PointerEvent-height"><code>height</code> <span class="idlAttrType">double</span> 타입, 읽기 전용</dt><dd>
				 포인터의 <a title="contact geometry" class="internalDFN" href="#dfn-contact-geometry">접촉 기하</a>인 CSS 픽셀 ([<cite><a class="bibref" href="#bib-CSS21">CSS21</a></cite>]) height (Y축 상 크기)
         이 값은 포인터가 주어진 각 이벤트별로 업데이트 할 수 있습니다. [<em class="rfc2119" title="MAY">MAY</em>]
         접촉 기하를 가지고 있지만 실제 기하를 하드웨어가 보고하지 않은 경우 디바이스의 기본 값을 <a title="user agent" class="internalDFN" href="#dfn-user-agent">유저 에이전트</a>가 그 포인터 타입의 대략적인 평균 형태로 제공해야만합니다. [<em class="rfc2119" title="SHOULD">SHOULD</em>] 다른 경우라면 이 값은 반드시 0입니다. [<em class="rfc2119" title="MUST">MUST</em>]
				</dd><dt id="widl-PointerEvent-pressure"><code>pressure</code> <span class="idlAttrType">float</span> 타입, 읽기 전용</dt><dd>
				 포인터 입력의 정상적인 압력은 [0,1] 범위로 나타내며, 0과 1은 각각 하드웨어가 감지 가능한 각각의 최소, 최대 압력을 나타냅니다.
         하드웨어가 압력을 지원하지 않은 경우, 마우스에 한정하지 않고 값은 <a title="active buttons" class="internalDFN" href="#dfn-active-buttons-state">버튼 활성화 상태</a>라면 0.5, 그 외의 경우는 0이어야 합니다. [<em class="rfc2119" title="MUST">MUST</em>]
				</dd><dt id="widl-PointerEvent-tiltX"><code>tiltX</code> <span class="idlAttrType">long</span> 타입, 읽기 전용</dt><dd>
					<p>
            Y-Z 평면 사이 (각도 상, [-90,90] 범위 내) 평면각과 (스타일러스 펜 같은) 변환기 축과 Y 축을 둘 다 포함하는 평면.
            양수 <code>tiltX</code>는 오른쪽. <code>tiltX</code>는 <code>tiltY</code>와 함께 디지타이저에서 변환기의 표준에서 멀리 기울어진 걸 나타낼 수 있습니다.
            만약 디바이스가 tilt를 보고하지 않을 경우, 값은 반드시 0입니다. [<em class="rfc2119" title="MUST">MUST</em>]
          </p>
					<figure id="fig-positive-tiltx.x">
						<img src="tiltX_600px.png" alt="tiltX explanation diagram">
						<figcaption>Fig. <span class="figno">2</span> <span class="fig-title">양수 <code>tiltX</code>.</span></figcaption>
					</figure>
				</dd><dt id="widl-PointerEvent-tiltY"><code>tiltY</code> <span class="idlAttrType">long</span> 타입, 읽기 전용</dt><dd>
          X-Z 평면 사이 (각도 상, [-90,90] 범위 내) 평면각과 (스타일러스 펜 같은) 변환기 축과 X 축을 둘 다 포함하는 평면.
					양수 <code>tiltY</code>는 유저 쪽에 있습니다. <code>tiltY</code>는 <code>tiltX</code>와 함께 디지타이저에서 변환기의 표준에서 멀리 기울어진 걸 나타낼 수 있습니다.
         만약 디바이스가 tilt를 보고하지 않을 경우, 값은 반드시 0입니다. [<em class="rfc2119" title="MUST">MUST</em>]
					<figure id="fig-negative-tilty.x">
						<img src="tiltY_600px.png" alt="tiltY explanation diagram">
						<figcaption>Fig. <span class="figno">3</span> <span class="fig-title">음수 <code>tiltY</code>.</span></figcaption>
					</figure>
				</dd><dt id="widl-PointerEvent-pointerType"><code>pointerType</code> <span class="idlAttrType">DOMString</span> 타입, 읽기 전용</dt><dd>
					<p>
            이벤트가 발생하는 디바이스 형태를 감지합니다 (마우스, 펜, 터치 등).
            만약 유저에이전트가 마우스, 스타일러스 펜, 터치 입력 디바이스나 다른 디바이스로 <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시킨 경우,
            <code>pointerType</code>은 반드시 아래 표를 따릅니다. [<em class="rfc2119" title="MUST">MUST</em>]
          </p>
					<table class="simple">
						<thead>
							<tr><th>Pointer Device Type</th><th><code>pointerType</code> Value</th></tr>
						</thead>
						<tbody>
							<tr><td>Mouse</td><td><code>mouse</code></td></tr>
							<tr><td>Pen Stylus</td><td><code>pen</code></td></tr>
							<tr><td>Touch Contact</td><td><code>touch</code></td></tr>
						</tbody>
					</table>
					<p>
            만약 유저 에이전트에서 디바이스 형태를 감지하지 못한다면, 값은 반드시 빈 문자열이어야 합니다. [<em class="rfc2119" title="MUST">MUST</em>]
            만약 유저 에이전트가 위 목록에 존재하는 게 아닌 다른 포인터 디바이스 타입을 지원한다면, 그 <code>pointerType</code> 값은,
            다른 디바이스 타입 이름과 충돌을 피하기 위해 벤더 프리픽스를 붙여야 합니다. [<em class="rfc2119" title="SHOULD">SHOULD</em>]
          </p>
					<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_5"><span>노트</span></div><section class="">
          어떻게 <code>pointerType</code>을 사용할 수 있는지에 대한 기본 데모는 <a href="#example_2" class="internalDFN" title="examples">예제 2</a>를 보시길 바랍니다.
          개발자들은 구현체가 커스텀 <code>pointerType</code> 값을 가지거나 <code>pointerType</code>에 빈 문자열을 넣을 가능성이 있는 유저 에이전트를 커버하기 위한 기본 처리를 포함하는 게 좋습니다.
          </section></div>
				</dd><dt id="widl-PointerEvent-isPrimary"><code>isPrimary</code> <span class="idlAttrType">boolean</span> 타입, 읽기 전용</dt><dd>
					포인터의 포인터 타입이 <a title="primary pointer" class="internalDFN" href="#dfn-primary-pointer">기본 포인터</a>인 경우를 나타냅니다.
				</dd></dl></section>
			<section><h4 id="dictionary-pointereventinit-members" role="heading"><a class="idlType" href="#idl-def-PointerEventInit"><code>PointerEventInit</code></a> 멤버 사전</h4><dl class="dictionary-members"><dt id="widl-PointerEventInit-pointerId"><code>pointerId</code> <span class="idlMemberType">long</span> 타입, 기본값 <code>0</code></dt><dd><code>PointerEvent</code>객체의 <code>pointerId</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-width"><code>width</code> <span class="idlMemberType">double</span> 타입, 기본값 <code>0</code></dt><dd><code>PointerEvent</code> 객체의 <code>width</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-height"><code>height</code> 타입 <span class="idlMemberType">double</span>, 기본값 <code>0</code></dt><dd><code>PointerEvent</code> 객체의 <code>height</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-pressure"><code>pressure</code> <span class="idlMemberType">float</span> 타입, 기본값 <code>0</code></dt><dd><code>PointerEvent</code> 객체의 <code>pressure</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-tiltX"><code>tiltX</code> 타입 <span class="idlMemberType">long</span>, 기본값 <code>0</code></dt><dd><code>PointerEvent</code> 객체의 <code>tiltX</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-tiltY"><code>tiltY</code> 타입 <span class="idlMemberType">long</span>, 기본값 <code>0</code></dt><dd><code>PointerEvent</code> 객체의 <code>tiltY</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-pointerType"><code>pointerType</code> 타입 <span class="idlMemberType">DOMString</span>, 기본값 <code>""</code></dt><dd><code>PointerEvent</code> 객체의 <code>pointerType</code> 속성을 초기화합니다.</dd><dt id="widl-PointerEventInit-isPrimary"><code>isPrimary</code> 타입 <span class="idlMemberType">boolean</span>, 기본값 <code>false</code></dt><dd><code>PointerEvent</code> 객체의 <code>isPrimary</code> 속성을 초기화합니다.</dd></dl></section>
			<div><code>PointerEventInit</code> 사전은 신뢰할 수 없는 (인위적인) 포인터 이벤트를 구축하는 메커니즘을 제공하기 위한 <code>PointerEvent</code> 인터페이스의 컨스트럭터로 사용합니다. 
        [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]에서 정의한 <code>MouseEventInit</code> 사전을 상속합니다.
        이벤트 구축 단계는 [<cite><a class="bibref" href="#bib-DOM4">DOM4</a></cite>]에서 정의합니다.
        신뢰할 수 없는 포인터 이벤트가 어떻게 발생하는 지에 대한 기본 데모 샘플 코드는 <a href="#examples" class="internalDFN" title="examples">예제</a>를 보시길 바랍니다.
      </div>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_6"><span>노트</span></div><div class=""><code>PointerEvent</code> 인터페이스는 [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]에서 정의하고 [<cite><a class="bibref" href="#bib-CSSOM-VIEW">CSSOM-VIEW</a></cite>]에서 확장한 <code>MouseEvent</code>를 상속한 것입니다.</div></div>
	    </div>
	    <section id="button-states">
			<h4 role="heading" id="h4_button-states"><span class="secno">5.1.1 </span>버튼 상태</h4>
			<section id="chorded-button-interactions">
				<h5 role="heading" id="h5_chorded-button-interactions"><span class="secno">5.1.1.1 </span><dfn title="chorded buttons" id="dfn-chorded-buttons">코드를 포함한 버튼 인터렉션</dfn></h5>
				<div><p>
          마우스나 펜 같은 몇몇 포인터 디바이스는 여러개의 버튼을 지원합니다.
          [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>] 마우스 이벤트 모델에서,
          각 버튼을 누르면 <code>mousedown</code>과 <code>mouseup</code> 이벤트를 제공합니다.
          이런 하드웨어 차이 및 크로스-디바이스 인풋 작성의 더 나은 추상화를 위해 
          포인터 이벤트는 <a title="chorded buttons" class="internalDFN" href="#dfn-chorded-buttons">코드를 포함한 버튼 인터렉션</a>을 위한 이벤트를 
          <code>pointerdown</code>과 <code>pointerup</code>를 오버래핑하여 발생시키지 않습니다. (포인터 디바이스에서 누르지 않은 추가 버튼은 이미 누르지 않은 상태입니다)
        </p>

        <p>
        대신, 코드를 포함한 버튼을 누른 것을 <code>button</code>과 <code>buttons</code> 속성의 변화를 검사하여 감지할 수 있습니다.
        <code>button</code>과 <code>buttons</code>속성은 [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>] <code>MouseEvent</code> 인터페이스에서 상속한 것입니다.
        (<code>pointerdown</code>과 <code>pointerup</code>뿐 아닌) 모든 포인터 이벤트에서 버튼 상태 전이 구별을 가능하게 하기 위하여,
         마우스 버튼을 누르지 않았을 때 <code>button</code> 속성에 새로운 값을 가지도록 합니다.
        </p>
				<table class="simple">
					<thead><tr><th>Device Button State</th><th><code>button</code></th><th><code>buttons</code></th></tr></thead>
					<tbody>
						<tr><td><b>버튼을 누르지 않은 채 마우스 이동</b></td><td>-1</td><td>0</td></tr>
						<tr><td>왼쪽 마우스 <br>터치 접촉<br>펜 접촉 (버튼 클릭 수식어를 가지지 않는)</td><td>0</td><td>1</td></tr>
						<tr><td>중간 마우스</td><td>1</td><td>4</td></tr>
						<tr><td>오른쪽 마우스<br> 배럴 버튼과 함께 눌러진 펜 접촉</td><td>2</td><td>2</td></tr>
						<tr><td>X1 (뒤) 마우스</td><td>3</td><td>8</td></tr>
						<tr><td>X2 (앞) 마우스</td><td>4</td><td>16</td></tr>
						<tr><td>지우개 버튼과 함께 눌러진 펜 접촉</td><td>5</td><td>32</td></tr>
					</tbody>
				</table>
				<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_7"><span>노트</span></div><section class="">
          이 값은 포인터 이벤트가 발생했을 때만 사용 가능합니다.
          이 스펙 문서에서 마우스 이벤트가 발생했을 때 사용 할 수 있는 <code>button</code>이나 <code>buttons</code> 값을 다루지 않습니다.
          마우스 이벤트가 발생했을 때 사용 가능한 값은 [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]를 참고하시길 바랍니다.
        </section></div>
				</div>
			</section>
		</section>
		<section id="the-primary-pointer">
			<h4 role="heading" id="h4_the-primary-pointer"><span class="secno">5.1.2 </span><dfn title="primary pointer" id="dfn-primary-pointer">기본 포인터</dfn></h4>
			<div><p>
        (멀티 터치 같은) 멀티 포인터 시나리오에서, 
        <a href="#widl-PointerEvent-isPrimary"><code>isPrimary</code></a> 속성은
        각 포인터 타입의 활성 포인터 세트 중 마스터 포인터를 식별할 때 사용합니다.
        기본 포인터만이 <a title="compatibility mouse events" class="internalDFN" href="#dfn-compatibility-mouse-events">호환 마우스 이벤트</a>를 만듭니다.
        싱글 포인터 동작을 원하는 작성자는 기본이 아닌 포인터를 거부하여 이룰 수 있습니다.
        (그러나, <a href="#multiple-primary-pointers">여러개의 기본 포인터</a>는 아래 주의를 보세요)
			</p><section>
				<h5 id="determining-the-primary-pointer" role="heading">기본 포인터 결정</h5>
				<div>포인터 이벤트가 발생할 때, 만약 포인터가 다음 내용에 일치한다면 기본으로 고려해야 합니다.
					<ul>
						<li>포인터가 마우스 디바이스를 나타냅니다.</li>
						<li>포인터가 기본 터치 입력을 나타냅니다.</li>
						<li>포인터가 기본 펜 입력을 나타냅니다.</li>
					</ul>
				</div>
				<dl>
					<dt>기본 터치 입력</dt><dd>
          터치 입력을 보여주는 포인터에서,
          만약 그 <code>pointerdown</code> 이벤트를
          존재하는 터치 입력을 나타내는 다른 활성화 포인터가 존재하지 않을 때 보냈다면
          <i>기본 터치 입력</i>으로 고려해야 합니다.
          </dd>
					<dt>기본 펜 입력</dt><dd>
          펜 입력을 보여주는 포인터에서,
          만약 그 <code>pointerdown</code> 이벤트를 
          존재하는 펜 입력을 나타내는 다른 활성화 포인터가 존재하지 않을 때 보냈다면
          <i>기본 펜 입력</i>으로 고려해야 합니다.
          </dd>
				</dl>
				<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_8"><span>포인터</span></div><div class="" id="multiple-primary-pointers">
          현재 두개 이상의 포인터 디바이스 타입을 사용하고 있을 때, 멀티플 포인터(각 <code>pointerType</code> 중 하나)를 기본으로 고려해야 합니다.
          예를 들어, 터치 접촉과 마우스 커서가 움직이고 있는 상황을 시뮬레이팅하면,
          양쪽 모두를 기본으로 고려한 포인터를 만들 것입니다.
          </div></div>
				<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_9"><span>노트</span></div><div class="">
          여러개의 <a href="#the-primary-pointer">기본 포인터가</a> 존재하는 상황에서,
          이 포인터는 모두 <a href="#compatibility-mapping-with-mouse-events">호환 마우스 이벤트</a>를 생성할 것입니다.
          </div></div>
				<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_10"><span>노트</span></div><div class="">
          몇몇 플랫폼에서,
          유저에이전트 타겟이 아닌 것을 포함한 (즉 다른 어플리케이션)
          디바이스 내 모든 활성 포인터를 기본 포인터로 지정합니다.
          이 뜻은 유저에이전트가 포인터 없이 이벤트를 발생할 수 있으며 그를 기본 포인터로 할 수 있다는 뜻입니다.
          예를 들어, 첫번째 터치 인터렉션이 대상 유저에이전트 밖에서 발생했고,
          두번째 (멀티 터치) 터치 인터렉션이 대상 유저에이전트 안에서 발생했을 때,
          유저 에이전트가 
          두번째 접촉 시 이벤트의 <code>isPrimary</code> 값을 <code>false</code>로 발생시킬 수 있습니다.
        </div></div>

			</section>
		</div></section>
     </section>
	 <section id="pointer-event-types">
		<h3 role="heading" id="h3_pointer-event-types"><span class="secno">5.2 </span>포인터 이벤트 타입</h3>
		<section id="firing-events-using-the-pointerevent-interface">
			<h4 role="heading" id="h4_firing-events-using-the-pointerevent-interface"><span class="secno">5.2.1 </span><code>PointerEvent</code> 인터페이스를 사용한 이벤트 발생</h4>
			<dfn id="dfn-fire-a-pointer-event-name-e">포인터 이벤트 e 발생</dfn>이 의미하는 바는
      [<cite><a class="bibref" href="#bib-DOM4">DOM4</a></cite>]에서 정의한
      <dfn id="dfn-fire-an-event-named-e">이벤트 e 발생</dfn>을
      <a href="#pointerevent-interface"><code>PointerEvent</code> 인터페이스</a>에서 정의하는 세트와 동일한 속성을 가진
      <a href="#idl-def-PointerEvent" class="idlType"><code>PointerEvent</code></a> 인터페이스와 함께 사용한 것을 의미합니다.
      <p></p>
			<p>
        아래 이벤트에서 <code>bubbles</code> 속성값은 <code>true</code>로 초기화합니다 :
				</p><ul>
					<li><code>pointerdown</code></li>
					<li><code>pointerup</code></li>
					<li><code>pointercancel</code></li>
					<li><code>pointermove</code></li>
					<li><code>pointerover</code></li>
					<li><code>pointerout</code></li>
					<li><code>gotpointercapture</code></li>
					<li><code>lostpointercapture</code></li>
				</ul>
			<p></p>
			<p>
        아래 이벤트에서 <code>cancelable</code> 속성값은 <code>true</code>로 초기화합니다 :
				</p><ul>
					<li><code>pointerdown</code></li>
					<li><code>pointerup</code></li>
					<li><code>pointermove</code></li>
					<li><code>pointerover</code></li>
					<li><code>pointerout</code></li>
				</ul>
			<p></p>

			<p>이벤트가 발생한 타겟 객체는 아래와 순서대로 결정합니다.
			</p><ul>
				<li><a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a>를 포인터에서 정의하는 경우,
					<ul>
						<li>이벤트의 <code>relatedTarget</code> 속성을 <code>null</code>로 지정합니다..</li>
						<li><a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a> 객체의 이벤트를 발생합니다.</li>
					</ul>
				</li>
				<li>
          그 외 경우에는, 이벤트 발생 객체는 일반 히트 테스트 메커니즘을 따라 반환합니다. (이 스펙 문서 범위에 속하지 않습니다)</li>
			</ul>
            <h4 id="process-pending-pointer-capture">포인터 캡쳐 미결 프로세스</h4>
            <p>
              유저에이전트에서 <code>gotpointercapture</code>나 <code>lostpointercapture</code>가 아닌 포인터 이벤트가 발생했을 때, 반드시 아래 스텝대로 먼저 동작해야합니다:
            </p>
            <ol>
                <li>
                  만약 이 포인터에서 <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a>로 세트되어있고 
                  <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a>와 같지 않은 경우,
                  <code>lostpointercapture</code> 이벤트는 <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a> 노드에서 발생합니다.
                </li>
                <li>
                  만약 이 포인터에서 <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a>로 세트되어있고 
                  <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a>와 같지 않은 경우,
                  <code>gotpointercapture</code> 이벤트는 <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a> 노드에서 발생합니다.
                    <ul>
                        <li>
                          더 나아가, <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a>가 세트되어있지 않고, <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a> 이 프로세스가 적용된 포인터 이벤트를 위한 히트테스트 노드와 같지 않고, 히트 테스트 노드가 <code>pointerover</code>와 <code>pointerenter</code> 이벤트를 받는 경우, <code>pointerout</code> 이벤트와 <code>pointerleave</code> 이벤트가 히스 테스트 노드에서 발생합니다.</li>
                    </ul>
                </li>
                <li>
                  세트한 경우, <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a>로
									<dfn id="dfn-pointer-capture-target-override">pointer capture target override</dfn>를 세트합니다.
                </li>
            </ol>
		</section>
		<section class="informative" id="list-of-pointer-events">
			<h4 role="heading" id="h4_list-of-pointer-events"><span class="secno">5.2.2 </span>포인터 이벤트 목록</h4>
      <p><em>이 섹션은 표준에 준하는 내용이 아닙니다.</em></p>
			<p>아래 표는 이 스펙문서에서 정의하는 이벤트 타입의 요약을 제공합니다.</p>
			<table class="parameters">
				<thead><tr>
					<th>이벤트 타입</th><th>Sync/Async</th><th>Bubbles</th><th>Cancelable</th><th>기본 동작</th></tr>
				</thead>
				<tbody>
					<tr>
						<td><code>pointerover</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>Yes</td>
            <td>다름: 포인터가 기본일 때, <code>mouseover</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>pointerenter</code></td>
						<td>Sync</td>
						<td>No</td>
						<td>No</td>
            <td>다름: 포인터가 기본일 때, <code>mouseenter</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>pointerdown</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>Yes</td>
            <td>다름: 포인터가 기본일 때, <code>mousedown</code> 이벤트의 모든 기본 동작
                <br>이 <code>pointerType</code>에서 <i>PREVENT MOUSE EVENT</i> 플래그가 세트되어 있으면 이 이벤트는 취소되며,
                특정 <a title="compatibility mouse events" class="internalDFN" href="#dfn-compatibility-mouse-events">호환 마우스 이벤트</a>
                발생 서브시퀀스를 막습니다.
            </td>
					</tr>
					<tr>
						<td><code>pointermove</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>Yes</td>
            <td>다름: 포인터가 기본일 때, <code>mousemove</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>pointerup</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>Yes</td>
            <td>다름: 포인터가 기본일 때, <code>mouseup</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>pointercancel</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>No</td>
						<td>없음</td>
					</tr>
					<tr>
						<td><code>pointerout</code></td>
						<td>Sync</td>
						<td>Yes</td>
						<td>Yes</td>
            <td>다름: 포인터가 기본일 때, <code>mouseout</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>pointerleave</code></td>
						<td>Sync</td>
						<td>No</td>
						<td>No</td>
            <td>다름: 포인터가 기본일 때, <code>mouseleave</code>의 모든 기본 동작</td>
					</tr>
					<tr>
						<td><code>gotpointercapture</code></td>
						<td>Sync/Async</td>
						<td>Yes</td>
						<td>No</td>
						<td>없음</td>
					</tr>
					<tr>
						<td><code>lostpointercapture</code></td>
						<td>Sync/Async</td>
						<td>Yes</td>
						<td>No</td>
						<td>없음</td>
					</tr>
				</tbody>
			</table>
		<p><a href="#the-primary-pointer">primary pointer</a>이 발생할 시 (<code>gotpointercapture</code>와 <code>lostpointercapture</code>를 제외하고),
    그 이벤트 또한 호환 마우스 이벤트로 발생합니다.</p>
		</section>
		<section id="the-pointerover-event">
			<h4 role="heading" id="h4_the-pointerover-event"><span class="secno">5.2.3 </span><dfn title="pointerover" id="dfn-pointerover"><code>pointerover</code> 이벤트</dfn></h4>
			<div>
                          유저 에이전트는  <em class="rfc2119" title="MUST">반드시</em> 포인팅 디바이스가 요소의 히트 테스트 범위 내에서 움직일 경우 <code>pointerover</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>] 유저에이전트는 <a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는 디바이스</a>에서 <em class="rfc2119" title="MUST">반드시</em> <code>pointerdown</code> 이벤트를 이 이벤트 대신 발생시켜야 합니다. (<code><a href="#the-pointerdown-event">pointerdown</a></code> 참고) [<em class="rfc2119" title="MUST">MUST</em>]</div>
		</section>
		<section id="the-pointerenter-event">
			<h4 role="heading" id="h4_the-pointerenter-event"><span class="secno">5.2.4 </span><dfn title="pointerenter" id="dfn-pointerenter"><code>pointerenter</code> 이벤트</dfn></h4>
                        <div>
                          유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em>  <a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는 디바이스</a>에서 발생한 <code>pointerdown</code> 결과값을 포함한 포인팅 디바이스가 요소나 그 자손의 히트 테스트 범위 내에서 움직일 경우 <code>pointerenter</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. (<code><a href="#the-pointerdown-event">pointerdown</a></code> 참고) [<em class="rfc2119" title="MUST">MUST</em>] 이 이벤트 타입은 <code>pointerover</code>와 비슷하나, 버블이 발생하지 않는 차이가 있습니다.</div>
			<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_11"><span>노트</span></div><div class="">
                        이 이벤트 타입은 [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]에서 설명하는 <code>mouseenter</code> 이벤트 및
                        [<cite><a class="bibref" href="#bib-CSS21">CSS21</a></cite>]에서 설명하는 CSS <code>:hover</code> 의사 클래스와 유사성을 가집니다.
                        <code>pointerleave</code> 이벤트도 확인하시길 바랍니다.
                        </div></div>
		</section>
		<section id="the-pointerdown-event">
			<h4 role="heading" id="h4_the-pointerdown-event"><span class="secno">5.2.5 </span><dfn title="pointerdown" id="dfn-pointerdown"><code>pointerdown</code> 이벤트</dfn></h4>
			<div>
                          <p>유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 포인터 이벤트가 <a title="active buttons state" class="internalDFN" href="#dfn-active-buttons-state">활성 버튼 상태</a>일 때 <code>pointerdown</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>] 마우스에서, 버튼이 눌리지 않은 상태에서 하나 이상의 버튼이 눌려진 사이를 나타냅니다. 터치에서, <a title="digitizer" class="internalDFN" href="#dfn-digitizer">디지타이저</a>에 물리적으로 접촉했을 때를 나타냅니다. 펜에서, 디지타이저에 스타일러스 펜이 물리적으로 접촉했을 때를 나타냅니다.</p>
            <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_12"><span>노트</span></div><div class="">
마우스(혹은 다른 여러개의 버튼을 가진 포인터 디바이스)에서, 이는 <code>pointerdown</code>과 <code>pointerup</code>이 <code>mousedown</code>과 <code>mouseup</code> 이벤트와 동일한 상황으로 발생하지 않음을 의미합니다. 더 자세한 정보는 <a href="#chorded-button-interactions" class="internalDFN">코드를 포함한 버튼</a>에서 확인 가능합니다.</div></div>
                        <p><a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는 디바이스</a> 입력에서, 유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>pointerdown</code> 이벤트의 처리 이후 <code>pointerenter</code> 이벤트에 잇달아 <code>pointerover</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>]</p>
			<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_13"><span>노트</span></div><div class="">
                          만약 <code>isPrimary</code> 속성값이 <code>true</code>인 경우 작성자는 특정 <code>pointerdown</code> 이벤트 무효로 인한 <a title="compatibility mouse events" class="internalDFN" href="#dfn-compatibility-mouse-events">호환 마우스 이벤트</a> 의 발생을 막을 수 있습니다. 이는 포인터에 PREVENT MOUSE EVENT FLAG를 세웁니다. 그러나, 이는 <code>mouseover</code>, <code>mouseenter</code>, <code>mouseout</code>, <code>mouseleave</code>로 발생한 이벤트는 막을 수 없습니다.
                        </div></div>
			</div>
		</section>
		<section id="the-pointermove-event">
			<h4 role="heading" id="h4_the-pointermove-event"><span class="secno">5.2.6 </span><dfn title="pointermove" id="dfn-pointermove"><code>pointermove</code> 이벤트</dfn></h4>
			<div>유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 포인터의 좌표가 바뀌었을 때 <code>pointermove</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. 여기에 더해, 버튼상태, 압력, 기울기, 접촉 기하 (즉 <code>width</code>와 <code>height</code>) 등 포인터가 변경되었을 때 및 상황이 이 스펙문서에서 정의하는 포인터 이벤트를 제공하지 않을 경우 유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>pointermove</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다.</div>
		</section>
		<section id="the-pointerup-event">
			<h4 role="heading" id="h4_the-pointerup-event"><span class="secno">5.2.7 </span><dfn title="pointerup" id="dfn-pointerup"><code>pointerup</code> 이벤트</dfn></h4>
			<div>
                          유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 포인터가 <a title="active buttons state" class="internalDFN" href="#dfn-active-buttons-state">활성 버튼 상태</a>를 벗어날 때 <code>pointerup</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>] 마우스에서, 하나 이상의 버튼이 눌린 상태에서 버튼이 눌리지 않은 사이를 나타냅니다. 터치에서, <a title="digitizer" class="internalDFN" href="#dfn-digitizer">디지타이저</a>에 물리적 접촉이 사라졌을 때를 나타냅니다. 펜에서, 디지타이저에 스타일러스 펜이 떼어졌을 때를 의미합니다.
                        <p><a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는 디바이스</a> 입력에서, 유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>pointerup</code> 이벤트의 처리 이후 <code>pointerleave</code> 이벤트에 잇달아 <code>pointerout</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>]</p>
			</div>
			<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_14"><span>노트</span></div><div class="">
마우스(혹은 다른 여러개의 버튼을 가진 포인터 디바이스)에서, 이는 <code>pointerdown</code>과 <code>pointerup</code>이 <code>mousedown</code>과 <code>mouseup</code> 이벤트와 동일한 상황으로 발생하지 않음을 의미합니다. 더 자세한 정보는 <a href="#chorded-button-interactions" class="internalDFN">코드를 포함한 버튼</a>에서 확인 가능합니다.</div></div>
		</section>
		<section id="the-pointercancel-event">
			<h4 role="heading" id="h4_the-pointercancel-event"><span class="secno">5.2.8 </span><dfn title="pointercancel" id="dfn-pointercancel"><code>pointercancel</code> 이벤트</dfn></h4>
			<div>유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 아래 상황에서 <code>pointercancel</code>  <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다.
				<ul>
					<li>유저 에이전트는 포인터가 제품 이벤트에 연이어지지 않도록 정의합니다. (예를 들어, 하드웨어 이벤트 같은 것들).</li>
					<li><code>pointerdown</code> 이벤트 발생 이후, 포인터가 그 이후에 페이지 뷰포트 조작에 사용될 수도 있습니다. (즉, 패닝이나 줌)</li>
				</ul>
				<p>
					<code>pointercancel</code>이벤트 발생 이후, 유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>pointerleave</code> 포인터 이벤트 발생에 뒤이어 <code>pointerout</code> 이벤트를 발생시켜야 합니다. [<em class="rfc2119" title="MUST">MUST</em>]</p>
				<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_15"><span>노트</span></div><div class="">
				<p><i>이 섹션은 표준에 준하는 내용이 아닙니다.</i></p>
					<p>유저 에이전트에서 포인터가 제품 이벤트에 연이어지지 않도록 정의가능한 시나리오의 예제에 다음 제품 이벤트를 포함합니다:
					</p><ul>
						<li>디바이스의 스크린 방향이 변경될 때 포인터가 활성화 됩니다.</li>
						<li>유저 입력값이 포인터 시뮬레이션 숫자보다 큰 경우 이는 디바이스에 의해 지원합니다.</li>
						<li>유저 에이전트가 accidental input을 해석할 경우 (예를 들어, 하드웨어가 팜 리젝션을 지원할 경우)</li>
					</ul>
					<p>
						디바이스의 스크린 방향 변경, accidental input 인식, 뷰포트 제어 포인터(즉, 패닝이나 줌)를 사용하는 방법은 이 스펙 문서의 범위에 포함하지 않습니다.
					</p>
				</div></div>
			</div>
		</section>
		<section id="the-pointerout-event">
			<h4 role="heading" id="h4_the-pointerout-event"><span class="secno">5.2.9 </span><dfn title="pointerout" id="dfn-pointerout"><code>pointerout</code> 이벤트</dfn></h4>
			<div>
				유저 에이전트는 아래와 같은 상황에서 <em class="rfc2119" title="MUST">반드시</em> <code>pointerout</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다 [<em class="rfc2119" title="MUST">MUST</em>]:
				<ul>
					<li>포인팅 디바이스가 요소의 히트 테스트 범위를 벗어난 경우</li>
					<li><a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는</a> 기기에서 <code>pointerup</code> 이벤트 발생 후 (<code><a href="#the-pointerup-event">pointerup</a></code>).</li>
					<li><code>pointercancel</code> 이벤트 발생 후 (<code><a href="#the-pointercancel-event">pointercancel</a></code>).</li>
					<li>스타일러스 펜이 디지타이저에서 인식할 수 있는 hover 범위를 벗어난 경우</li>
				</ul>
			</div>
		</section>
		<section id="the-pointerleave-event">
			<h4 role="heading" id="h4_the-pointerleave-event"><span class="secno">5.2.10 </span><dfn title="pointerleave" id="dfn-pointerleave"><code>pointerleave</code> 이벤트</dfn></h4>
			<div>유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 요소나 그 모든 자손의 히트 테스트 범위를 벗어난 경우 <a href="#mapping-for-devices-that-do-not-support-hover">hover를 지원하지 않는</a> 기기에서 발생한 <code>pointerup</code> 및 <code>pointercancel</code> 이벤트의 결과를 포함하여 <code>pointerleave</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다 [<em class="rfc2119" title="MUST">MUST</em>] (<code><a href="#the-pointerup-event">pointerup</a></code> 및 <code><a href="#the-pointercancel-event">pointercancel</a></code>도 보시길 바랍니다).
				유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> 스타일러스 펜이 디지타이저에서 인식할 수 있는 hover 범위를 벗어난 경우 <code>pointerleave</code><a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. 이 이벤트 타입은 <code>pointerout</code>과 비슷하지만, 버블이 일어나지 않으며, <em class="rfc2119" title="MUST">반드시</em> 포인팅 디바이스가 요소 및 요소의 모든 자손의 범위를 벗어났을 때 발생하지 않는다는 차이가 있습니다.</div>
			<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_16"><span>노트</span></div><div class="">
이 이벤트 타입과 비슷한 것들로, [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>]에서 설명하는 <code>mouseleave</code> 이벤트와, [<cite><a class="bibref" href="#bib-CSS21">CSS21</a></cite>]에서 소개하는 CSS <code>:hover</code> 의사 클래스가 있습니다. <code>pointerenter</code> 이벤트도 확인해보세요.</div></div>
		</section>
		<section id="the-gotpointercapture-event">
			<h4 role="heading" id="h4_the-gotpointercapture-event"><span class="secno">5.2.11 </span><dfn title="gotpointercapture" id="dfn-gotpointercapture"><code>gotpointercapture</code> 이벤트</dfn></h4>
			<div>
				요소가 포인터 캡쳐를 수신할 때, 유저에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>gotpointercapture</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다 [<em class="rfc2119" title="MUST">MUST</em>] 이 이벤트는 포인터 캡쳐를 받은 요소에서 발생합니다.
				해당 포인트에 대한 후속 이벤트가 요소에서 발생합니다. 
				<a href="#setting-pointer-capture">Setting Pointer Capture</a> 및 <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> 섹션을 보시길 바랍니다.
			</div>
		</section>
		<section id="the-lostpointercapture-event">
			<h4 role="heading" id="h4_the-lostpointercapture-event"><span class="secno">5.2.12 </span><dfn title="lostpointercapture" id="dfn-lostpointercapture">The <code>lostpointercapture</code> event</dfn></h4>
			<div>
포인터를 위한 포인터 캡쳐 릴리즈 이후 유저 에이전트는 <em class="rfc2119" title="MUST">반드시</em> <code>lostpointercapture</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다 [<em class="rfc2119" title="MUST">MUST</em>] 이 이벤트는 <em class="rfc2119" title="MUST">반드시</em> 캡쳐가 릴리즈된 이후 포인터 후속 이벤트보다 먼저 발생해야만 합니다. 이 이벤트는 포인터 캡쳐가 제거된 요소에서 발생합니다. 포인터를 위한 후속 이벤트는 이벤트 타겟을 결정하는 히트 테스팅 메커니즘을 따릅니다. (이 스펙문서의 범위에 포함되지 않습니다) <a href="#releasing-pointer-capture">Releasing Pointer Capture</a>, <a href="#implicit-release-of-pointer-capture">Implicit Release of Pointer Capture</a>, <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> 섹션을 참고하시길 바랍니다.</div>
		</section>
   </section>
</section>
<section id="extensions-to-the-element-interface">
	<!--OddPage--><h2 role="heading" id="h2_extensions-to-the-element-interface"><span class="secno">6. </span><code>Element</code> 인터페이스 확장</h2>
	<p>아래 섹션에서는 이미 존재하는 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]에서 정의하는 <code>Element</code> 인터페이스에서 포인터 캡쳐의 해제 및 설정을 용이하게 하는 확장을 설명합니다.</p>
	<div>
		<pre class="idl"><span class="idlInterface" id="idl-def-Element">partial interface <span class="idlInterfaceID">Element</span> {
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-Element-ongotpointercapture">ongotpointercapture</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-Element-onlostpointercapture">onlostpointercapture</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-Element-setPointerCapture-void-long-pointerId">setPointerCapture</a></span> (<span class="idlParam"><span class="idlParamType">long</span> <span class="idlParamName">pointerId</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-Element-releasePointerCapture-void-long-pointerId">releasePointerCapture</a></span> (<span class="idlParam"><span class="idlParamType">long</span> <span class="idlParamName">pointerId</span></span>);</span>
};</span></pre><section><h3 id="attributes-2" role="heading">속성</h3><dl class="attributes"><dt id="widl-Element-ongotpointercapture"><code>ongotpointercapture</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
			<code>gotpointercapture</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]) 
			</dd><dt id="widl-Element-onlostpointercapture"><code>onlostpointercapture</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
			<code>lostpointercapture</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]).
			</dd></dl></section><section><h3 id="methods" role="heading">Methods</h3><dl class="methods"><dt id="widl-Element-setPointerCapture-void-long-pointerId"><code>setPointerCapture</code></dt><dd>
				<p>
이 메서드는 호출한 요소에 인수 <code>pointerId</code>로 식별하는 포인터를 위한 <a href="#setting-pointer-capture">포인터 캡쳐를 설정</a>합니다.
캡쳐가 해제될 때까지 포인터 후속 이벤트는 항상 이 요소를 대상으로 해야합니다. [<em class="rfc2119" title="MUST">MUST</em>]
포인터는 반드시 이 메서드를 효율적으로 다루기 위해 활성 버튼 상태에 있어야 합니다, 그 외의 경우에는 자동으로 실패상태입니다. [<em class="rfc2119" title="MUST">MUST</em>]
메서드의 인수가 어떤 <a title="active pointer" class="internalDFN" href="#dfn-active-pointer">활성 포인터</a>와도 매치하지 않는 경우
<code>InvalidPointerId</code> 이름을 가진 <code>DOMException</code>을 던질 수 있습니다.</p>
				<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_17"><span>노트</span></div><div class=""><a href="#dfn-pointer-capture" title="pointer capture" class="internalDFN">Pointer Capture</a>를 확인하시길 바랍니다.</div></div>
			<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">pointerId</td><td class="prmType"><code>long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-Element-releasePointerCapture-void-long-pointerId"><code>releasePointerCapture</code></dt><dd>
				<p>
이 메서드는 호출한 요소에 인수 <code>pointerId</code>로 식별하는 포인터를 위한 <a href="#releasing-pointer-capture">포인터 캡쳐를 해제</a>합니다.
포인터 후속 이벤트는 이벤트 타겟을 결정하기 위해 히트 테스팅 메커니즘을 따라야 합니다. (이 스펙 문서의 범위에 포함하지 않습니다.)
메서드의 인수가 어떤 <a title="active pointer" class="internalDFN" href="#dfn-active-pointer">활성 포인터</a>와도 매치하지 않는 경우
<code>InvalidPointerId</code> 이름을 가진 <code>DOMException</code>을 던질 수 있습니다.</p>
				<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_18"><span>노트</span></div><div class=""><a href="#dfn-pointer-capture" title="pointer capture" class="internalDFN">Pointer Capture</a>를 확인하시길 바랍니다.</div></div>
			<table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">pointerId</td><td class="prmType"><code>long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
</div></section>
<section id="extensions-to-the-globaleventhandlers-interface">
	<!--OddPage--><h2 role="heading" id="h2_extensions-to-the-globaleventhandlers-interface"><span class="secno">7. </span><code>GlobalEventHandlers</code> 인터페이스 확장</h2>
	<p>아래 섹션에서는 이미 존재하는 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]에서 정의하는 <code>GlobalEventHandlers</code> 인터페이스에서 이벤트 핸들러 등록을 용이하게 하는 확장을 설명합니다.</p>
		<pre class="idl"><span class="idlInterface" id="idl-def-GlobalEventHandlers">partial interface <span class="idlInterfaceID">GlobalEventHandlers</span> {
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerdown">onpointerdown</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointermove">onpointermove</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerup">onpointerup</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointercancel">onpointercancel</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerover">onpointerover</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerout">onpointerout</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerenter">onpointerenter</a></span>;</span>
<span class="idlAttribute">                attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-GlobalEventHandlers-onpointerleave">onpointerleave</a></span>;</span>
};</span></pre><section id="attributes"><h3 role="heading" id="h3_attributes"><span class="secno">7.1 </span>Attributes</h3><dl class="attributes"><dt id="widl-GlobalEventHandlers-onpointerdown"><code>onpointerdown</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
			<code>pointerdown</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointermove"><code>onpointermove</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				<code>pointermove</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointerup"><code>onpointerup</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				<code>pointerup</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointercancel"><code>onpointercancel</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				 <code>pointercancel</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointerover"><code>onpointerover</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				 <code>pointerover</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointerout"><code>onpointerout</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				 <code>pointerout</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointerenter"><code>onpointerenter</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				 <code>pointerenter</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd><dt id="widl-GlobalEventHandlers-onpointerleave"><code>onpointerleave</code> 타입 <span class="idlAttrType">EventHandler</span>,            </dt><dd>
				 <code>pointerleave</code> 이벤트 타입을 위한 이벤트 핸들러 IDL 속성 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>])
			</dd></dl></section>

</section>

<section id="extensions-to-the-navigator-interface">
	<!--OddPage--><h2 role="heading" id="h2_extensions-to-the-navigator-interface"><span class="secno">8. </span><code>Navigator</code> 인터페이스 확장</h2>
	<div>
	<p>
<code>Navigator</code> 인터페이스는 [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>]에서 정의하고 있습니다. 이 스펙문서에서는 <code>Navigator</code> 인터페이스에서 디바이스를 제공하고 특징 감지 지원을 하기 위해 확장합니다.</p>
		<pre class="idl"><span class="idlInterface" id="idl-def-Navigator">partial interface <span class="idlInterfaceID">Navigator</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">long</span> <span class="idlAttrName"><a href="#widl-Navigator-maxTouchPoints">maxTouchPoints</a></span>;</span>
};</span></pre><section><h3 id="attributes-3" role="heading">Attributes</h3><dl class="attributes"><dt id="widl-Navigator-maxTouchPoints"><code>maxTouchPoints</code> 타입 <span class="idlAttrType">long</span>, 읽기 전용</dt><dd>
<p>
디바이스에 의해 지원하는 터치 접촉 시뮬레이션의 최대 숫자입니다. 여러개의 디지타이저 (예를 들면 여러개의 터치스크린)을 가진 디바이스를 예로 들면,
이 값은 반드시 각 개별 디지타이저에서 지원하는 접촉의 최대값으로 설정해야할 것입니다. [<em class="rfc2119" title="MUST">MUST</em>]
</p>
<p>
예를 들어, 3개의 터치스크린을 가진 디바이스를 지원하고, 2, 5, 10 터치 접촉을 지원한다고 가정해봅시다.
<code>maxTouchPoints</code> 값은 반드시 <code>10</code>이어야만 합니다.
</p>
</dd></dl></section>
<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_19"><span>노트</span></div><div class="">
	0보다 큰 <code>maxTouchPoints</code> 값은 사용자의 디바이스가 터치 입력을 지원한다고 나타내지만,
	반드시 사용자가 터치입력을 사용하는 것을 의미하지는 않습니다.
	작성자는 마우스, 펜, 스크린 리더 등 시스템에 존재할 수 있는 다른 입력양식을 고려하고 주의해야 합니다.
</div></div>
		<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_20"><span>노트</span></div><div class="">
<code>maxTouchPoints</code>은 종종 하드웨어가 인식할 수 있도록 콘텐츠의 인터렉션 모델을 보장하기 위해 사용합니다.
UI 어포던스는 적은 하드웨어 능력을 유저에게 제공할 수 있습니다.
터치 포인트의 정확한 갯수를 플랫폼에서 알 수 없을 때, 최소 개수를 제공하여 인식을 보장합니다.
인식되는 터치 포인트의 갯수가 <code>maxTouchPoints</code>를 초과하는 것도 가능합니다.</div></div>
	</div>
</section>
<section id="declaring-candidate-regions-for-default-touch-behaviors">
	<!--OddPage--><h2 role="heading" id="h2_declaring-candidate-regions-for-default-touch-behaviors"><span class="secno">9. </span>디폴트 터치 동작을 위한 후보 영역 선언</h2>
	<p>터치 인풋에서, 모든 기본 액션과 포인트 이벤트는 뷰포트의 조작이 아니어야 합니다. (예. 패닝이나 주밍) [<em class="rfc2119" title="MUST NOT">MUST NOT</em>]</p>
	<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_21"><span>노트</span></div><div class="">터치 조작은 포인터 이벤트의 디폴트 액션이 의도적으로 아니어야 합니다. 이벤트 취소 의존성을 제거함으로써 유저 에이전트 성능 최적화를 용이하게 합니다.</div></div>
	<section id="the-touch-action-css-property">
		<h3 role="heading" id="h3_the-touch-action-css-property"><span class="secno">9.1 </span>CSS <code>touch-action</code> 속성</h3>
		<table class="simple">
			<tbody><tr><th>Name:</th><td><code>touch-action</code></td></tr>
			<tr><th>Value:</th><td><code>auto</code> | <code>none</code> | [ <code>pan-x</code> || <code>pan-y</code> ] | <code>manipulation</code></td></tr>
			<tr><th>Initial:</th><td><code>auto</code></td></tr>
			<tr><th>Applies to:</th><td>all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups.</td></tr>
			<tr><th>Inherited:</th><td>no</td></tr>
			<tr><th>Percentages:</th><td>N/A</td></tr>
			<tr><th>Media:</th><td>visual</td></tr>
			<tr><th>Computed value:</th><td>Same as specified value.</td></tr>
		</tbody></table>
		<div>
			<p>CSS <code>touch-action</code> 속성은 유저 에이전트에서 제공하는 터치 인풋의 기본 동작 트리거를 결정합니다. [<em class="rfc2119" title="MAY">MAY</em>]
			이는 패닝 혹은 주밍과 같은 동작에 제한되지 않습니다.</p>

			<p>값은 아래 의미를 가집니다.</p>
			<dl>
				<dt>auto</dt><dd>유저 에이전트에서 요소로부터 시작한 터치에서 뷰포트의 조작을 위한 패닝과 주밍같은 터치 행동을 허용. [<em class="rfc2119" title="MAY">MAY</em>]</dd>
				<dt>none</dt><dd>요소로부터 시작한 터치 기본 동작 트리거가 동작하지 않음. [<em class="rfc2119" title="MUST NOT">MUST NOT</em>]</dd>
				<dt>pan-x</dt><dd>유저 에이전트는 가로 스크롤 콘텐츠와 가장 가까운 상위 요소의 가로 스크롤을 목적으로 하기 위한 요소로 시작하는 터치를 고려할 수 있습니다. [<em class="rfc2119" title="MAY">MAY</em>]</dd>
				<dt>pan-y</dt><dd>유저 에이전트는 세로 스크롤 콘텐츠와 가장 가까운 상위 요소의 세로 스크롤을 목적으로 하기 위한 요소로 시작하는 터치를 고려할 수 있습니다. [<em class="rfc2119" title="MAY">MAY</em>]</dd>
				<dt>manipulation</dt><dd>유저에이전트는 스크롤 및 지속적인 주밍을 목적으로 하기 위한 요소로 시작하는 터치를 고려할 수 있습니다. [<em class="rfc2119" title="MAY">MAY</em>] <code>auto</code>에서 지원하는 모든 추가동작은 이 스펙문서의 범위에 포함하지 않습니다.</dd>
			</dl>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_22"><span>노트</span></div><section class="">용어 "pan"과 "scroll"은 동의어로 고려해야합니다. 패닝이나 스크롤링 트리거 및 <code>auto</code> 나 <code>none</code> 값을 위한 트리거 동작을 위한 인터렉션 및 제스쳐 정의는 이 스펙 문서의 범위에 포함하지 않습니다.</section></div>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_23"><span>노트</span></div><section class="">
				<code>touch-action</code> 속성은 CSS <code>width</code>와 <code>height</code> 속성을 지원하는 요소에만 적용 가능합니다. ([<cite><a class="bibref" href="#bib-CSS21">CSS21</a></cite>]). 
        이 제약사항은 유저 에이전트가 <span>저 지연</span> 터치 액션을 위한 최적화를 가능하도록 설계되었습니다.
				<span>치환되지 않은 inline 요소</span> <code>&lt;span&gt;</code> 같은 default로 지원하지 않는 요소 ([<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>] 참고)를 위해 작성자는
				CSS 속성 <code>display</code>를 <code>block</code>과 같이 설정할 수 있으며, 이는 <code>width</code>와 <code>height</code>를 가질 수 있게 할 것입니다.
				미래의 스펙문서는 이 API를 모든 요소에서 사용 가능하도록 할 것입니다.</section></div>
			<p>
				요소에서 유저 터치가 일어날 때, 그 터치의 효과는 <code>touch-action</code> 속성의 값과 요소의 기본 터치 동작, 그리고 그 조상에 의해 결정해야 합니다.
				터치의 효과를 정의할 때, 인접한 조상(터치가 일어난 요소에서 시작하여)을 찾고 그 터치 동작을 기본으로 합니다. 
				그 후에 기본 터치 동작 요소와 히트 테스트 요소 사이 각 요소의 <code>touch-action</code> 속성을 조사합니다. (히트 테스트 요소와 기본 터치 동작 요소 양쪽 다 포함합니다)
        만약 그 요소 중 어떤 요소의 <code>touch-action</code> 속성이 기본 터치 동작을 허용하지 않는다면, 아무것도 하지 않습니다.
				그 외의 경우 요소에서 기본 터치 동작 실행의 목적에 맞게 터치를 시작하는 걸 허용합니다.
			</p>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_24"><span>노트</span></div><section class="">
				몇 유저 에이전트는 여러 동시에 발생하는 포인터의 인터렉션에 의해 걸리는 터치 액션을 지원합니다. (예를 들어 멀티 터치)
				여러 동시에 발생하는 포인터의 <code>touch-action</code> 값을 적용하고 처리하는 메서드는 이 스펙문서의 범위에 포함하지 않습니다.</section></div>
			<p>
				유저 에이전트에서 터치 동작을 실행하는 동안, 유저 에이전트는 반드시 포인터의 후속 포인터 이벤트를 발생시켜서는 안됩니다. [<em class="rfc2119" title="MUST NOT">MUST NOT</em>]
				유저 에이전트는 반드시 아래 케이스 모두가 true이며, 포인터 이벤트의 stream를 끝내기 위해서 <em class="rfc2119" title="MUST">반드시</em> <code>pointercancel</code> <a href="#firing-events-using-the-pointerevent-interface">포인터 이벤트를 발생</a>시켜야 합니다. (그리고 후속으로 <code>pointerout</code> 이벤트와 하나 이상의 <code>pointerleave</code> 이벤트를 발생시켜야 합니다)</p>
			<ul>
				<li>유저 에이전트가 터치 입력이 터치 동작을 위해 소비될 것이라 판단한 경우, (이 문서의 범위에 포함하지 않은 메서드를 이용하여)</li>
				<li><code>pointerdown</code> 이벤트가 포인터를 위해 보내졌으며, </li>
				<li><code>pointerup</code>이나 <code>pointercancel</code> 이벤트가 아직 (위에서 언급한 <code>pointerdown</code>에 따라) 포인터를 위해 보내지지 않은 경우</li>
			</ul>
<div class="example"><div class="example-title"><span>예제 5</span>: 모든 터치 동작을 허용하지 않는 예제</div><pre id="example_5" class="example">&lt;div style="touch-action: none;"&gt;
    This element receives pointer events for all touches.
&lt;/div&gt;</pre></div>
<div class="example"><div class="example-title"><span>예제 6</span>: 수평 패닝만 허용하는 경우</div><pre id="example_6" class="example">&lt;div style="touch-action: pan-x;"&gt;
    This element receives pointer events when not panning in the horizontal direction.
&lt;/div&gt;</pre></div>
<div class="example"><div class="example-title"><span>예제 7</span>: 터치 동작을 허용하지 않는 자식 영역</div><pre id="example_7" class="example">&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: none;"&gt;
        This element receives pointer events for all touches.
    &lt;/div&gt;
    &lt;div&gt;
        Touches on this element MAY be consumed for manipulating the parent.
    &lt;/div&gt;
&lt;/div&gt;	</pre></div>
<div class="example"><div class="example-title"><span>예제 8</span>: 터치 동작을 허용하지 않는 중간 부모</div><pre id="example_8" class="example">&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: pan-y;"&gt;
        &lt;div style="touch-action: pan-x;"&gt;
            This element receives pointer events for all touches because
            it allows only horizontal panning yet an intermediate ancestor
            (between it and the pannable element) only allows vertical panning.
            Therefore, no touch behaviors are allowed.
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;	</pre></div>
		</div>
	</section>
</section>
<section id="pointer-capture">
<!--OddPage--><h2 role="heading" id="h2_pointer-capture"><span class="secno">10. </span><dfn title="Pointer Capture" id="dfn-pointer-capture">포인터 캡쳐</dfn></h2>
	<div class="informative">
	<p>
	Pointer capture allows the events for a particular pointer (including any compatibility mouse events) to be retargeted to a particular element other than the normal hit test result of the pointer's location. This is useful in scenarios like a custom slider control (e.g. similar to the [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>] <code>&lt;input type="range"&gt;</code> control). Pointer capture can be set on the slider thumb element, allowing the user to slide the control back and forth even if the pointer slides off of the thumb.</p>
	<figure id="fig-example-of-a-custom-slider-control-that-chooses-a-value-by-sliding-the-thumb-element-back-and-forth.-after-pointerdown-on-the-thumb-pointer-capture-can-be-used-to-allow-the-user-to-slide-the-thumb-even-if-the-pointer-drifts-off-of-it.x">
		<img src="slider.png" alt="Custom Volume Slider">
		<figcaption>Fig. <span class="figno">4</span> <span class="fig-title">Example of a custom slider control that chooses a value by sliding the thumb element back and forth. After <code>pointerdown</code> on the thumb, pointer capture can be used to allow the user to slide the thumb even if the pointer drifts off of it.</span></figcaption>
	</figure>
	</div>

	<section id="setting-pointer-capture">
		<h3 role="heading" id="h3_setting-pointer-capture"><span class="secno">10.1 </span>Setting Pointer Capture</h3>
		Pointer capture is set on an element by calling the <code>element.setPointerCapture(pointerId)</code> method. When this method is invoked, a user agent <em class="rfc2119" title="MUST">MUST</em> run the following steps:
		<ol>
			<li>If the <code>pointerId</code> provided as the method's argument does not match any of the <a title="active pointer" class="internalDFN" href="#dfn-active-pointer">active pointers</a>, then throw a <code>DOMException</code> with the name <code>InvalidPointerId</code>.</li>
            <li>If the <code>Element</code> on which this method is invoked does not participate in its <code>ownerDocument</code>'s tree, throw an exception with the name <code>InvalidStateError</code>.</li>
			<li>If the pointer is not in the <a title="active buttons state" class="internalDFN" href="#dfn-active-buttons-state">active buttons</a> state, then terminate these steps.</li>
			<li>For the specified <code>pointerId</code>, set the <dfn id="dfn-pending-pointer-capture-target-override">pending pointer capture target override</dfn> to the <code>Element</code> on which this method was invoked.</li>
		</ol>
		<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_25"><span>Note</span></div><div class="">When pointer capture is set, <code>pointerover</code>, <code>pointerout</code>, <code>pointerenter</code>, and <code>pointerleave</code> events are only generated when crossing the boundary of the element that has capture as other elements can no longer be targeted by the pointer. This has the effect of suppressing these events on all other elements.</div></div>

	</section>

	<section id="releasing-pointer-capture">
		<h3 role="heading" id="h3_releasing-pointer-capture"><span class="secno">10.2 </span>Releasing Pointer Capture</h3>
		Pointer capture is released on an element explicitly by calling the <code>element.releasePointerCapture(pointerId)</code> method. When this method is called, a user agent <em class="rfc2119" title="MUST">MUST</em> run the following steps:
		<ol>
			<li>If the <code>pointerId</code> provided as the method's argument does not match any of the <a title="active pointer" class="internalDFN" href="#dfn-active-pointer">active pointers</a> and these steps are not being invoked as a result of the <a href="#implicit-release-of-pointer-capture">implicit release of pointer capture</a>, then throw a <code>DOMException</code> with the name <code>InvalidPointerId</code>.</li>
			<li>If pointer capture is not currently set for the specified pointer, then terminate these steps.</li>
			<li>If the <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a> for the specified <code>pointerId</code> is not the <code>Element</code> on which this method was invoked, then terminate these steps.</li>
			<li>For the specified <code>pointerId</code>, clear the <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a>, if set.</li>
		</ol>
	</section>
  <section id="implicit-pointer-capture">
        <h3 role="heading" id="h3_implicit-pointer-capture"><span class="secno">10.3 </span>Implicit Pointer Capture</h3>
        <div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_26"><span>Note</span></div><div class="">Some user agents implement their own implicit pointer capture behavior - for instance, for touch interactions, a user agent could automatically capture the pointer as part of an interaction on a form control (such as a button) to improve user interaction (allowing some finger movement to stray outside of the form control itself during the interaction). As part of this behavior, user agents typically fire <code>gotpointercapture</code> and <code>lostpointercapture</code> events, even though no explicit pointer capture functions (<code>setPointerCapture</code> and <code>releasePointerCapture</code>) were called.</div></div>
        <section id="implicit-release-of-pointer-capture">
        <h4 role="heading" id="h4_implicit-release-of-pointer-capture"><span class="secno">10.3.1 </span>Implicit Release of Pointer Capture</h4>
        <p>Immediately after firing the <code>pointerup</code> or <code>pointercancel</code> events, a user agent <em class="rfc2119" title="MUST">MUST</em> run the steps as if the <code>releasePointerCapture()</code> method has been called with an argument equal to the <code>pointerId</code> property of the <code>pointerup</code> or <code>pointercancel</code> event just dispatched.</p>
        <p>When the <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a> is removed from its <code>ownerDocument</code>'s tree, clear the <a href="#dfn-pending-pointer-capture-target-override" class="internalDFN">pending pointer capture target override</a> and <a href="#dfn-pointer-capture-target-override" class="internalDFN">pointer capture target override</a> nodes and fire a PointerEvent named <code>lostpointercapture</code> at the document.</p>
        </section>
    </section>
</section>
<section id="compatibility-mapping-with-mouse-events">
		<!--OddPage--><h2 role="heading" id="h2_compatibility-mapping-with-mouse-events"><span class="secno">11. </span><dfn title="compatibility mouse events" id="dfn-compatibility-mouse-events">Compatibility Mapping with Mouse Events</dfn></h2>
		<div><p>The vast majority of web content existing today codes only to Mouse Events. The following describes an algorithm for how a user agent <em class="rfc2119" title="MAY">MAY</em> map generic pointer input to mouse events for compatibility with this content. </p>
        <p>Unless otherwise noted, the target of any mapped mouse event <em class="rfc2119" title="SHOULD">SHOULD</em> be the same target as the respective pointer event unless the target is no longer participating in its <code>ownerDocument</code>'s tree. In this case, the mouse event should be fired at the original target's nearest ancestor node (at the time it was removed from the tree) that still participates in its <code>ownerDocument</code>'s tree, meaning that a new event path (based on the new target node) is built for the mouse event.</p>
		<p>Authors can prevent the production of certain compatibility mouse events by canceling the <code>pointerdown</code> event. </p>
		<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_27"><span>Note</span></div><section class="">Mouse events can only be prevented when the pointer is down.  Hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented. And, the <code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code>, and <code>mouseleave</code> events are never prevented (even if the pointer is down).</section></div>
		<p>The compatibility mapping with mouse events are an <em class="rfc2119" title="OPTIONAL">OPTIONAL</em> feature of this specification. User agents are encouraged to support the feature for best compatibility with existing legacy content. User agents that do not support compatibility mouse events are still encouraged to support the <code>click</code> and <code>contextmenu</code> events (see the note below).</p>
		<div class="note"><div class="note-title" aria-level="1" role="heading" id="h_note_28"><span>Note</span></div><section class="">
			<p>The <code>click</code> event, defined in [<cite><a class="bibref" href="#bib-DOM-LEVEL-3-EVENTS">DOM-LEVEL-3-EVENTS</a></cite>], and the <code>contextmenu</code> event, defined in [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>], are not considered <a title="compatibility mouse events" class="internalDFN" href="#dfn-compatibility-mouse-events">compatibility mouse events</a> as they are typically tied to user interface activation and are fired from other input devices, like keyboards.</p>
			<p>In user agents that support firing <code>click</code> and/or <code>contextmenu</code>, calling <code>preventDefault</code> during a pointer event typically does not have an effect on whether <code>click</code> and/or <code>contextmenu</code> are fired or not.  Because they are not compatibility mouse events, user agents typically fire <code>click</code> and <code>contextmenu</code> for all pointing devices, including pointers that are not primary pointers.</p>
			<p>The relative ordering of these high-level events (<code>click</code>, <code>contextmenu</code>, <code>focus</code>, <code>blur</code>, etc.) with pointer events is undefined and varies between user agents. For example, in some user agents <code>contextmenu</code> will often follow a <code>pointerup</code>, in others it'll often precede a <code>pointerup</code> or <code>pointercancel</code>, and in some situations it may be fired without any corresponding pointer event (such as a keyboard shortcut).</p>
		</section></div>
		</div>
		<section id="mapping-for-devices-that-support-hover">
			<h3 role="heading" id="h3_mapping-for-devices-that-support-hover"><span class="secno">11.1 </span>Mapping for devices that support hover</h3>
			<div>Whenever a user agent is to dispatch a pointer event for a device that supports hover, it <em class="rfc2119" title="MAY">MAY</em> run the following steps:
				<ol>
					<li>If the <code>isPrimary</code> property for the pointer event to be dispatched is <code>false</code> then dispatch the pointer event and terminate these steps.</li>
					<li>Dispatch the pointer event.</li>
					<li>If the pointer event dispatched was <code>pointerdown</code> and the event was <a title="canceled event" class="internalDFN" href="#dfn-canceled-event">canceled</a>, then set the <i>PREVENT MOUSE EVENT</i> flag for this <code>pointerType</code>.</li>
					<li>If the pointer event dispatched was:
						<ul>
							<li><code>pointerover</code>, then fire a <code>mouseover</code> event.</li>
							<li><code>pointerout</code>, then fire a <code>mouseout</code> event.</li>
							<li><code>pointerenter</code>, then fire a <code>mouseenter</code> event.</li>
							<li><code>pointerleave</code>, then fire a <code>mouseleave</code> event.</li>
						</ul>
                    </li>
					<li>If the <i>PREVENT MOUSE EVENT</i> flag is <b>not</b> set for this <code>pointerType</code> and the pointer event dispatched was:
						<ul>
							<li><code>pointerdown</code>, then fire a <code>mousedown</code> event.</li>
							<li><code>pointermove</code>, then fire a <code>mousemove</code> event.</li>
							<li><code>pointerup</code>, then fire a <code>mouseup</code> event.</li>
							<li><code>pointercancel</code>, then fire a <code>mouseup</code> event <b>at the <code>window</code>.</b></li>
						</ul>
					</li>
					<li>If the pointer event dispatched was <code>pointerup</code> or <code>pointercancel</code>, clear the <i>PREVENT MOUSE EVENT</i> flag for this <code>pointerType</code>.</li>
				</ol>
			</div>
		</section>
		<section id="mapping-for-devices-that-do-not-support-hover">
			<h3 role="heading" id="h3_mapping-for-devices-that-do-not-support-hover"><span class="secno">11.2 </span>Mapping for devices that do not support hover</h3>
			<div>Some devices, such as most touchscreens, do not support hovering a coordinate (or set of coordinates) while not in the active state. Much existing content coded to mouse events assumes that a mouse is producing the events and thus certain qualities are generally true:
			<ul>
				<li>The input can hover independently of activation (e.g. moving a mouse cursor without any buttons pressed).</li>
				<li>The input will likely produce the <code>mousemove</code> event on an element before clicking it.</li>
			</ul>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_29"><span>Note</span></div><section class="">Hover is sometimes used to toggle the visibility of UI elements in content designed for mouse (e.g. "hover menus"). This content is often incompatible with <a href="#mapping-for-devices-that-do-not-support-hover">devices that do not support hover</a>. This specification does not define a mapping or behavior for compatibility with this scenario. It will be considered in a future version of the specification.
			</section></div>
			This requires that user agents provide a different mapping for these types of input devices. Whenever a user agent is to dispatch a pointer event for a device that <a href="#mapping-for-devices-that-do-not-support-hover">does not support hover</a>, it <em class="rfc2119" title="MAY">MAY</em> run the following steps:
				<ol>
					<li>If the <code>isPrimary</code> property for the pointer event to be dispatched is <code>false</code> then dispatch the pointer event and terminate these steps.</li>
					<li>If the pointer event to be dispatched is <code>pointerover</code> and the <code>pointerdown</code> event has not yet been dispatched for this pointer, then fire a <code>mousemove</code> event (for compatibility with legacy mouse-specific code).</li>
					<li>Dispatch the pointer event.</li>
					<li>If the pointer event dispatched was <code>pointerdown</code> and the event was <a title="canceled event" class="internalDFN" href="#dfn-canceled-event">canceled</a>, then set the <i>PREVENT MOUSE EVENT</i> flag for this <code>pointerType</code>.</li>
					<li>If the pointer event dispatched was:
						<ul>
							<li><code>pointerover</code>, then fire a <code>mouseover</code> event.</li>
							<li><code>pointerout</code>, then fire a <code>mouseout</code> event.</li>
							<li><code>pointerenter</code>, then fire a <code>mouseenter</code> event.</li>
							<li><code>pointerleave</code>, then fire a <code>mouseleave</code> event.</li>
						</ul>
					</li>
					<li>If the <i>PREVENT MOUSE EVENT</i> flag is <b>not</b> set for this <code>pointerType</code> and the pointer event dispatched was:
						<ul>
							<li><code>pointerdown</code>, then fire a <code>mousedown</code> event.</li>
							<li><code>pointermove</code>, then fire a <code>mousemove</code> event.</li>
							<li><code>pointerup</code>, then fire a <code>mouseup</code> event.</li>
							<li><code>pointercancel</code>, then fire a <code>mouseup</code> event at the <code>window</code>.</li>
						</ul>
					</li>
					<li>If the pointer event dispatched was <code>pointerup</code> or <code>pointercancel</code>, clear the <i>PREVENT MOUSE EVENT</i> flag for this <code>pointerType</code>.</li>
				</ol>
			</div>
			<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_30"><span>Note</span></div><section class="">
			<p>The activation of an element (<code>click</code>) with a primary pointer that <a href="#mapping-for-devices-that-do-not-support-hover">does not support hover</a> (e.g. single finger on a touchscreen) would typically produce the following event sequence:</p>
			<ol data-class="note-list">
				<li><code>mousemove</code></li>
				<li><code>pointerover</code></li>
				<li><code>mouseover</code></li>
				<li><code>pointerenter</code></li>
				<li><code>mouseenter</code></li>
				<li><code>pointerdown</code></li>
				<li><code>mousedown</code></li>
				<li>Zero or more <code>pointermove</code> and <code>mousemove</code> events, depending on movement of the pointer</li>
				<li><code>pointerup</code></li>
				<li><code>mouseup</code></li>
				<li><code>click</code></li>
				<li><code>pointerout</code></li>
				<li><code>mouseout</code></li>
				<li><code>mouseleave</code></li>
			</ol>
			<p>If, however, the <code>pointerdown</code> event is canceled during this interaction then the sequence of events would be:
			</p><ol data-class="note-list">
				<li><code>mousemove</code></li>
				<li><code>pointerover</code></li>
				<li><code>mouseover</code></li>
				<li><code>pointerenter</code></li>
				<li><code>mouseenter</code></li>
				<li><code>pointerdown</code></li>
				<li>Zero or more <code>pointermove</code> events, depending on movement of the pointer</li>
				<li><code>pointerup</code></li>
				<li><code>click</code></li>
				<li><code>pointerout</code></li>
				<li><code>mouseout</code></li>
				<li><code>mouseleave</code></li>
			</ol>
			</section></div>
		</section>
	</section>
    <section class="appendix" id="acknowledgments">
      <!--OddPage--><h2 role="heading" id="h2_acknowledgments"><span class="secno">A. </span>Acknowledgments</h2>
      <p>
        Many thanks to lots of people for their proposals and recommendations, some of which
        are incorporated into this document. The group's Chair acknowledges contributions from the following
	group members:
		Arthur Barstow,
		Matt Brubeck,
		Rick Byers,
		Cathy Chan,
		Scott González,
		Patrick H. Lauke,
		Sangwhan Moon,
		Olli Pettay,
		Jacob Rossi,
		Doug Schepers and
		Asir Vedamuthu.
	  </p><p>
		Special thanks to those that helped pioneer the first edition of this model, including especially: Charu Chandiram, Peter Freiling, Nathan Furtwangler, Thomas Olsen, Matt Rakow, Ramu Ramanathan, Justin Rogers, Jacob Rossi, Reed Townsend, Steve Wright.
      </p>
    </section>
	<section class="appendix informative" id="revision-history">
		<!--OddPage--><h2 role="heading" id="h2_revision-history"><span class="secno">B. </span>Revision History</h2><p><em>This section is non-normative.</em></p>
		<p>The following is an informative summary of substantial and major editorial changes between publications of this specification. A complete revision history of the Editor's Drafts of this specification can be found <a href="https://dvcs.w3.org/hg/pointerevents/log/0b155c9163fb/pointerEvents.html">here</a>.</p>
    <h2 id="changes-since-the-13-november-2014-last-call-draft">Changes Since the 13 November 2014 Last Call Draft</h2>
    <ul>
      <li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2014OctDec/0094.html">Mail</a> - various editorial changes and clarification and added non-normative author guidance for maxTouchPoints</li>
    </ul>
		<h2 id="changes-since-the-09-may-2013-candidate-recommendation">Changes Since the 09 May 2013 Candidate Recommendation</h2>
		<ul>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013OctDec/0028.html">Mail</a> - Clarified pointerover/pointerout behavior with pointer capture</li>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013OctDec/0010.html">Mail</a> - Clarified maxTouchPoints behavior on platforms with less granular information</li>
		</ul>
		<h3 id="changes-since-the-19-february-2013-last-call-draft" role="heading">Changes Since the 19 February 2013 Last Call Draft</h3><p><em>This section is non-normative.</em></p>
		<ul>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013JanMar/0110.html">Mail</a> - Examples moved to front of spec</li>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013JanMar/0169.html">Mail</a> - Clarified contextmenu is not a compatibility mouse event</li>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013JanMar/0146.html">Mail</a> - Added non-normative note about pointerId selection algorithm
			</li><li><a href="http://www.w3.org/2013/03/26-pointerevents-minutes.html#item06">Mail</a> - Add missing Document, Window definitions for pointer event handlers</li>
			<li><a href="https://dvcs.w3.org/hg/pointerevents/rev/91af8c100600">Mail</a> - Clarified pointer capture events are asynchronous</li>
			<li><a href="https://dvcs.w3.org/hg/pointerevents/rev/9e15214ee5c5">Mail</a> - Clarified multiple primary pointers may be active at once</li>
			<li><a href="https://dvcs.w3.org/hg/pointerevents/rev/0da5982bcc84">Mail</a> - Clarified spec positioning in introduction</li>
			<li><a href="https://dvcs.w3.org/hg/pointerevents/rev/d24dd1d54803">Mail</a> - Moved constructor dictionary to be next to PointerEvent definition</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21746">21746</a> - Removed contradictory requirement for pointerId to be 1 for mouse</li>
			<li><a href="http://lists.w3.org/Archives/Public/public-pointer-events/2013AprJun/0064.html">Mail</a> - Clarified block-level restriction for touch-action</li>
		</ul>
		<h3 id="last-call-draft-dated-19-february-2013">Last Call Draft dated 19 February 2013</h3>
		<ul>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20710">20710</a> - Clarified the touch-action processing model.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20217">20217</a> - Expanded touch-action property to include additional values: pan-x and pan-y.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20109">20109</a> - Changed emulation value for devices that do not support pressure from 1 to 0.5, added emulation for width/height</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20222">20222</a> - Clarified that for hover menus the behavior is implementation-defined.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20872">20872</a> - Clarified that multiple concurrent pointers can be primary.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=21032">21032</a> - Reworded introduction to clarify goals</li>
		</ul>
		<h3 id="second-working-draft-dated-15-january-2013">Second Working Draft dated 15 January 2013</h3>
		<ul>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20107">20107</a> - Added a new set of button and buttons values to accommodate pen contact with eraser button pressed.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20108">20108</a> - Added additional pointer capture details.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20109">20109</a> - Added emulation (default values) for devices that do not support pressure.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20112">20112</a> - Added pointerenter and pointerleave events using the same model as mouseenter and mouseleave.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20219">20219</a> - Changed pointerType from long to DOMString.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20220">20220</a> - Removed hwTimestamp in favor of a future DOM Event high-resolution timestamp.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20221">20221</a> - Added constructor dictionary for PointerEvent.</li>
			<li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20281">20281</a> - Changed width and height to be CSS pixels instead of device pixels.</li>
		</ul>
	</section>
	<!-- appendix -->


<section id="references" class="appendix" typeof="bibo:Chapter" resource="#references" rel="bibo:Chapter"><!--OddPage--><h2 role="heading" id="h2_references"><span class="secno">C. </span>References</h2><section id="normative-references" typeof="bibo:Chapter" resource="#normative-references" rel="bibo:Chapter"><h3 role="heading" id="h3_normative-references"><span class="secno">C.1 </span>Normative references</h3><dl class="bibliography" about=""><dt id="bib-DOM-LEVEL-3-EVENTS">[DOM-LEVEL-3-EVENTS]</dt><dd rel="dcterms:requires">Gary Kacmarcik; Travis Leithead; Jacob Rossi; Doug Schepers; Björn Höhrmann; Philippe Le Hégaret; Tom Pixley. <a href="http://www.w3.org/TR/DOM-Level-3-Events/"><cite>Document Object Model (DOM) Level 3 Events Specification</cite></a>. 25 September 2014. W3C Working Draft. URL: <a href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a>
</dd><dt id="bib-DOM4">[DOM4]</dt><dd rel="dcterms:requires">Anne van Kesteren; Aryeh Gregor; Ms2ger; Alex Russell; Robin Berjon. <a href="http://www.w3.org/TR/dom/"><cite>W3C DOM4</cite></a>. Last Call Working Draft. URL: <a href="http://www.w3.org/TR/dom/">http://www.w3.org/TR/dom/</a>
</dd><dt id="bib-HTML5">[HTML5]</dt><dd rel="dcterms:requires">Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. <a href="http://www.w3.org/TR/html5/"><cite>HTML5</cite></a>. 28 October 2014. W3C Recommendation. URL: <a href="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd rel="dcterms:requires">S. Bradner. <a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>
</dd></dl></section><section id="informative-references" typeof="bibo:Chapter" resource="#informative-references" rel="bibo:Chapter"><h3 role="heading" id="h3_informative-references"><span class="secno">C.2 </span>Informative references</h3><dl class="bibliography" about=""><dt id="bib-CSS21">[CSS21]</dt><dd rel="dcterms:references">Bert Bos; Tantek Çelik; Ian Hickson; Håkon Wium Lie et al. <a href="http://www.w3.org/TR/CSS2"><cite>Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</cite></a>. 7 June 2011. W3C Recommendation. URL: <a href="http://www.w3.org/TR/CSS2">http://www.w3.org/TR/CSS2</a>
</dd><dt id="bib-CSSOM-VIEW">[CSSOM-VIEW]</dt><dd rel="dcterms:references">Simon Pieters; Glenn Adams. <a href="http://www.w3.org/TR/cssom-view/"><cite>CSSOM View Module</cite></a>. 17 December 2013. W3C Working Draft. URL: <a href="http://www.w3.org/TR/cssom-view/">http://www.w3.org/TR/cssom-view/</a>
</dd></dl></section></section></body></html>
